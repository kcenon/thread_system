<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thread System: utility_module::convert_string Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Thread System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/d2a/namespaceutility__module.html">utility_module</a></li><li class="navelem"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html">convert_string</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="../../de/dc1/classutility__module_1_1convert__string-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">utility_module::convert_string Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides utilities for string encoding conversion, Base64 encoding/decoding, and substring operations like splitting or replacing.  
 <a href="../../d1/d53/classutility__module_1_1convert__string.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d1/d46/convert__string_8h_source.html">convert_string.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for utility_module::convert_string:</div>
<div class="dyncontent">
<div class="center"><img src="../../d5/d70/classutility__module_1_1convert__string__coll__graph.png" border="0" usemap="#autility__module_1_1convert__string_coll__map" alt="Collaboration graph"/></div>
<map name="autility__module_1_1convert__string_coll__map" id="autility__module_1_1convert__string_coll__map">
<area shape="rect" title="Provides utilities for string encoding conversion, Base64 encoding/decoding, and substring operations..." alt="" coords="5,5,197,585"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a253963501540b93269546be1be251f6e" id="r_a253963501540b93269546be1be251f6e"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a253963501540b93269546be1be251f6e">to_string</a> (const std::wstring &amp;value) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a253963501540b93269546be1be251f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <code>std::wstring</code> to a <code>std::string</code> using the system encoding.  <br /></td></tr>
<tr class="separator:a253963501540b93269546be1be251f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776bbd0131c66d25b5704348286bcbfd" id="r_a776bbd0131c66d25b5704348286bcbfd"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a776bbd0131c66d25b5704348286bcbfd">to_string</a> (std::wstring_view value) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a776bbd0131c66d25b5704348286bcbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <code>std::wstring_view</code> to a <code>std::string</code> using the system encoding.  <br /></td></tr>
<tr class="separator:a776bbd0131c66d25b5704348286bcbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b61bbabdc9b7a5118130f5330a928d4" id="r_a8b61bbabdc9b7a5118130f5330a928d4"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a8b61bbabdc9b7a5118130f5330a928d4">to_wstring</a> (const std::string &amp;value) -&gt; std::tuple&lt; std::optional&lt; std::wstring &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a8b61bbabdc9b7a5118130f5330a928d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <code>std::string</code> (system-encoded) to a <code>std::wstring</code>.  <br /></td></tr>
<tr class="separator:a8b61bbabdc9b7a5118130f5330a928d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29faff84bcbfaff3f9216b89f9b38619" id="r_a29faff84bcbfaff3f9216b89f9b38619"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a29faff84bcbfaff3f9216b89f9b38619">to_wstring</a> (std::string_view value) -&gt; std::tuple&lt; std::optional&lt; std::wstring &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a29faff84bcbfaff3f9216b89f9b38619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <code>std::string_view</code> (system-encoded) to a <code>std::wstring</code>.  <br /></td></tr>
<tr class="separator:a29faff84bcbfaff3f9216b89f9b38619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c39f9c977f20e433d4f1ddc13a3eb5" id="r_a72c39f9c977f20e433d4f1ddc13a3eb5"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a72c39f9c977f20e433d4f1ddc13a3eb5">get_system_code_page</a> () -&gt; int</td></tr>
<tr class="memdesc:a72c39f9c977f20e433d4f1ddc13a3eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the system code page used for conversions.  <br /></td></tr>
<tr class="separator:a72c39f9c977f20e433d4f1ddc13a3eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30f587d85f8caf0bdcfddf109d60ce0" id="r_ad30f587d85f8caf0bdcfddf109d60ce0"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#ad30f587d85f8caf0bdcfddf109d60ce0">system_to_utf8</a> (const std::string &amp;value) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:ad30f587d85f8caf0bdcfddf109d60ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a system-encoded string to UTF-8.  <br /></td></tr>
<tr class="separator:ad30f587d85f8caf0bdcfddf109d60ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95c2d5708b124dc8b5ef30588de6975" id="r_ae95c2d5708b124dc8b5ef30588de6975"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#ae95c2d5708b124dc8b5ef30588de6975">utf8_to_system</a> (const std::string &amp;value) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:ae95c2d5708b124dc8b5ef30588de6975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF-8 encoded string to the system encoding.  <br /></td></tr>
<tr class="separator:ae95c2d5708b124dc8b5ef30588de6975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38229e1d31f5460f04aad36890d6fde" id="r_af38229e1d31f5460f04aad36890d6fde"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#af38229e1d31f5460f04aad36890d6fde">split</a> (const std::string &amp;source, const std::string &amp;token) -&gt; std::tuple&lt; std::optional&lt; std::vector&lt; std::string &gt; &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:af38229e1d31f5460f04aad36890d6fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string by a given delimiter.  <br /></td></tr>
<tr class="separator:af38229e1d31f5460f04aad36890d6fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774607516416d24843fce7ef3cb8d593" id="r_a774607516416d24843fce7ef3cb8d593"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a774607516416d24843fce7ef3cb8d593">to_array</a> (const std::string &amp;value) -&gt; std::tuple&lt; std::optional&lt; std::vector&lt; uint8_t &gt; &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a774607516416d24843fce7ef3cb8d593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a system-encoded string to a UTF-8 byte array.  <br /></td></tr>
<tr class="separator:a774607516416d24843fce7ef3cb8d593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaae4329ae07d19deada3f5d53d2fe9e" id="r_aeaae4329ae07d19deada3f5d53d2fe9e"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#aeaae4329ae07d19deada3f5d53d2fe9e">to_string</a> (const std::vector&lt; uint8_t &gt; &amp;value) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:aeaae4329ae07d19deada3f5d53d2fe9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF-8 byte array to a system-encoded string.  <br /></td></tr>
<tr class="separator:aeaae4329ae07d19deada3f5d53d2fe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc64202472f47e2bf91bc607e8250a2" id="r_a6cc64202472f47e2bf91bc607e8250a2"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a6cc64202472f47e2bf91bc607e8250a2">to_base64</a> (const std::vector&lt; uint8_t &gt; &amp;value) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a6cc64202472f47e2bf91bc607e8250a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes a byte array into a Base64 string.  <br /></td></tr>
<tr class="separator:a6cc64202472f47e2bf91bc607e8250a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118786eba66d84cd2a02c911775141ec" id="r_a118786eba66d84cd2a02c911775141ec"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a118786eba66d84cd2a02c911775141ec">from_base64</a> (const std::string &amp;base64_str) -&gt; std::tuple&lt; std::vector&lt; uint8_t &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a118786eba66d84cd2a02c911775141ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a Base64 string into a byte array.  <br /></td></tr>
<tr class="separator:a118786eba66d84cd2a02c911775141ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f62dd34644ec32bead2a2826c85d79" id="r_af4f62dd34644ec32bead2a2826c85d79"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#af4f62dd34644ec32bead2a2826c85d79">replace</a> (std::string &amp;source, const std::string &amp;token, const std::string &amp;target) -&gt; std::optional&lt; std::string &gt;</td></tr>
<tr class="memdesc:af4f62dd34644ec32bead2a2826c85d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of <code>token</code> in <code>source</code> with <code>target</code>, in place.  <br /></td></tr>
<tr class="separator:af4f62dd34644ec32bead2a2826c85d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735255ee06de6baa6f70ddd97b724402" id="r_a735255ee06de6baa6f70ddd97b724402"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a735255ee06de6baa6f70ddd97b724402">replace2</a> (const std::string &amp;source, const std::string &amp;token, const std::string &amp;target) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a735255ee06de6baa6f70ddd97b724402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of <code>token</code> in <code>source</code> with <code>target</code>, returning a new string.  <br /></td></tr>
<tr class="separator:a735255ee06de6baa6f70ddd97b724402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:afbde2f9b7be55d89662baedd43ba63cf" id="r_afbde2f9b7be55d89662baedd43ba63cf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a> { <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">little</a>
, <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4">big</a>
, <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaad921d60486366258809553a3db49a4a">unknown</a>
 }</td></tr>
<tr class="memdesc:afbde2f9b7be55d89662baedd43ba63cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible endianness values for UTF-16 or UTF-32 data.  <a href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">More...</a><br /></td></tr>
<tr class="separator:afbde2f9b7be55d89662baedd43ba63cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea78e52dff286b9309465a9b0f993a4" id="r_a6ea78e52dff286b9309465a9b0f993a4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4">encoding_types</a> { <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">utf8</a>
, <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a5ab39c2bd546655547f6101ed91e395e">utf16</a>
, <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a1c067a9fa89e2bf1d6dd55a6ca6204ce">utf32</a>
 }</td></tr>
<tr class="memdesc:a6ea78e52dff286b9309465a9b0f993a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported encoding types used in iconv-based conversions.  <a href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4">More...</a><br /></td></tr>
<tr class="separator:a6ea78e52dff286b9309465a9b0f993a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a8d073801a85c823fefc5f2c00e40a2f5" id="r_a8d073801a85c823fefc5f2c00e40a2f5"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a8d073801a85c823fefc5f2c00e40a2f5">get_code_page_name</a> (int code_page) -&gt; std::string</td></tr>
<tr class="memdesc:a8d073801a85c823fefc5f2c00e40a2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a textual name for a code page (e.g., "CP_ACP" or a locale-based name).  <br /></td></tr>
<tr class="separator:a8d073801a85c823fefc5f2c00e40a2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316651c671cec003dc927423e12d2466" id="r_a316651c671cec003dc927423e12d2466"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a316651c671cec003dc927423e12d2466">get_encoding_name</a> (<a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4">encoding_types</a> encoding, <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a> endian=<a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>) -&gt; std::string</td></tr>
<tr class="memdesc:a316651c671cec003dc927423e12d2466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the encoding name used by iconv based on <code>encoding</code> and <code>endian</code>.  <br /></td></tr>
<tr class="separator:a316651c671cec003dc927423e12d2466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445b122955236c6ca960ac541810a3d2" id="r_a445b122955236c6ca960ac541810a3d2"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a445b122955236c6ca960ac541810a3d2">get_wchar_encoding</a> (<a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a> endian=<a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>) -&gt; std::string</td></tr>
<tr class="memdesc:a445b122955236c6ca960ac541810a3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derives the wchar_t encoding name based on its size and endianness.  <br /></td></tr>
<tr class="separator:a445b122955236c6ca960ac541810a3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4cf9e1164a4cb47d032b1d4f1caaad" id="r_aff4cf9e1164a4cb47d032b1d4f1caaad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff4cf9e1164a4cb47d032b1d4f1caaad"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#aff4cf9e1164a4cb47d032b1d4f1caaad">string_to_vector</a> (const T &amp;value) -&gt; std::vector&lt; char &gt;</td></tr>
<tr class="memdesc:aff4cf9e1164a4cb47d032b1d4f1caaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string (or wide string) to a <code>std::vector&lt;char&gt;</code> for iconv processing.  <br /></td></tr>
<tr class="separator:aff4cf9e1164a4cb47d032b1d4f1caaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd95bc09617a96479dfb71d15869dd43" id="r_abd95bc09617a96479dfb71d15869dd43"><td class="memTemplParams" colspan="2">template&lt;typename FromType , typename ToType &gt; </td></tr>
<tr class="memitem:abd95bc09617a96479dfb71d15869dd43"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#abd95bc09617a96479dfb71d15869dd43">convert</a> (const FromType &amp;value, const std::string &amp;from_encoding, const std::string &amp;to_encoding) -&gt; std::tuple&lt; std::optional&lt; ToType &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:abd95bc09617a96479dfb71d15869dd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from one encoding to another using <code>iconv</code> or equivalent APIs.  <br /></td></tr>
<tr class="separator:abd95bc09617a96479dfb71d15869dd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9caabbf474f464993f50e7d48e09a89" id="r_aa9caabbf474f464993f50e7d48e09a89"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#aa9caabbf474f464993f50e7d48e09a89">detect_endian</a> (const std::u16string &amp;value) -&gt; <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a></td></tr>
<tr class="memdesc:aa9caabbf474f464993f50e7d48e09a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects the endianness of a UTF-16 string by checking for BOM or content patterns.  <br /></td></tr>
<tr class="separator:aa9caabbf474f464993f50e7d48e09a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97a673c0e90ad30e5fee349f7112f52" id="r_ae97a673c0e90ad30e5fee349f7112f52"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#ae97a673c0e90ad30e5fee349f7112f52">detect_endian</a> (const std::u32string &amp;value) -&gt; <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a></td></tr>
<tr class="memdesc:ae97a673c0e90ad30e5fee349f7112f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects the endianness of a UTF-32 string by checking for BOM or content patterns.  <br /></td></tr>
<tr class="separator:ae97a673c0e90ad30e5fee349f7112f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78b53cb309a989bbc39ffbbcb73054b" id="r_ae78b53cb309a989bbc39ffbbcb73054b"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#ae78b53cb309a989bbc39ffbbcb73054b">has_utf8_bom</a> (const std::string &amp;value) -&gt; bool</td></tr>
<tr class="memdesc:ae78b53cb309a989bbc39ffbbcb73054b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a string has a UTF-8 BOM (Byte Order Mark).  <br /></td></tr>
<tr class="separator:ae78b53cb309a989bbc39ffbbcb73054b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfae97e9adf04f637025406457671f57" id="r_adfae97e9adf04f637025406457671f57"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#adfae97e9adf04f637025406457671f57">remove_utf8_bom</a> (const std::string &amp;value) -&gt; std::string</td></tr>
<tr class="memdesc:adfae97e9adf04f637025406457671f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a leading UTF-8 BOM from a string, if present.  <br /></td></tr>
<tr class="separator:adfae97e9adf04f637025406457671f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3886358e768fe8b41226184e21e9eaa9" id="r_a3886358e768fe8b41226184e21e9eaa9"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a3886358e768fe8b41226184e21e9eaa9">add_utf8_bom</a> (const std::string &amp;value) -&gt; std::string</td></tr>
<tr class="memdesc:a3886358e768fe8b41226184e21e9eaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a UTF-8 BOM to a string if it doesn't already have one.  <br /></td></tr>
<tr class="separator:a3886358e768fe8b41226184e21e9eaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30592e4ca22ebe9b45f847e7d4eed464" id="r_a30592e4ca22ebe9b45f847e7d4eed464"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a30592e4ca22ebe9b45f847e7d4eed464">base64_encode</a> (const std::vector&lt; uint8_t &gt; &amp;data) -&gt; std::string</td></tr>
<tr class="memdesc:a30592e4ca22ebe9b45f847e7d4eed464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes a byte array into a Base64 string.  <br /></td></tr>
<tr class="separator:a30592e4ca22ebe9b45f847e7d4eed464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486c32b21f68395d8ecc2f96b49b2fcf" id="r_a486c32b21f68395d8ecc2f96b49b2fcf"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a486c32b21f68395d8ecc2f96b49b2fcf">base64_decode</a> (const std::string &amp;base64_str) -&gt; std::tuple&lt; std::vector&lt; uint8_t &gt;, std::optional&lt; std::string &gt; &gt;</td></tr>
<tr class="memdesc:a486c32b21f68395d8ecc2f96b49b2fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a Base64 string into a byte array.  <br /></td></tr>
<tr class="separator:a486c32b21f68395d8ecc2f96b49b2fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides utilities for string encoding conversion, Base64 encoding/decoding, and substring operations like splitting or replacing. </p>
<p>This class relies on platform-specific APIs or <code>iconv</code> (when available) to convert strings between different encodings such as UTF-8, UTF-16, UTF-32, and the local system encoding. It also provides methods to handle Base64 encoding/decoding and some basic string manipulation (split, replace).</p>
<h3><a class="anchor" id="autotoc_md51"></a>
Encoding Conversions</h3>
<ul>
<li>Typically returns a tuple containing either a successful result (<code>std::optional&lt;T&gt;</code>) and an empty error (<code>std::nullopt</code>), or <code>std::nullopt</code> with an error message describing the failure.</li>
<li>BOM (Byte Order Mark) is handled in certain functions for UTF-8, UTF-16, and UTF-32.</li>
</ul>
<h3><a class="anchor" id="autotoc_md52"></a>
Base64</h3>
<ul>
<li>Encodes and decodes raw byte arrays (<code>std::vector&lt;uint8_t&gt;</code>).</li>
</ul>
<h3><a class="anchor" id="autotoc_md53"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Converting a wstring to system-encoded string</span></div>
<div class="line"><span class="keyword">auto</span> [strOpt, errMsg] = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a253963501540b93269546be1be251f6e">convert_string::to_string</a>(L<span class="stringliteral">&quot;안녕하세요&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (!strOpt) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; *errMsg &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Converted string: &quot;</span> &lt;&lt; *strOpt &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a253963501540b93269546be1be251f6e"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a253963501540b93269546be1be251f6e">utility_module::convert_string::to_string</a></div><div class="ttdeci">static auto to_string(const std::wstring &amp;value) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</div><div class="ttdoc">Converts a std::wstring to a std::string using the system encoding.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00095">convert_string.cpp:95</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="../../d1/d46/convert__string_8h_source.html#l00077">77</a> of file <a class="el" href="../../d1/d46/convert__string_8h_source.html">convert_string.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6ea78e52dff286b9309465a9b0f993a4" name="a6ea78e52dff286b9309465a9b0f993a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea78e52dff286b9309465a9b0f993a4">&#9670;&#160;</a></span>encoding_types</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4">utility_module::convert_string::encoding_types</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supported encoding types used in iconv-based conversions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb" name="a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb"></a>utf8&#160;</td><td class="fielddoc"><p>UTF-8 encoding. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6ea78e52dff286b9309465a9b0f993a4a5ab39c2bd546655547f6101ed91e395e" name="a6ea78e52dff286b9309465a9b0f993a4a5ab39c2bd546655547f6101ed91e395e"></a>utf16&#160;</td><td class="fielddoc"><p>UTF-16 encoding. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6ea78e52dff286b9309465a9b0f993a4a1c067a9fa89e2bf1d6dd55a6ca6204ce" name="a6ea78e52dff286b9309465a9b0f993a4a1c067a9fa89e2bf1d6dd55a6ca6204ce"></a>utf32&#160;</td><td class="fielddoc"><p>UTF-32 encoding. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d1/d46/convert__string_8h_source.html#l00247">247</a> of file <a class="el" href="../../d1/d46/convert__string_8h_source.html">convert_string.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  248</span>        {</div>
<div class="line"><span class="lineno">  249</span>            <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">utf8</a>,  </div>
<div class="line"><span class="lineno">  250</span>            <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a5ab39c2bd546655547f6101ed91e395e">utf16</a>, </div>
<div class="line"><span class="lineno">  251</span>            <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a1c067a9fa89e2bf1d6dd55a6ca6204ce">utf32</a>  </div>
<div class="line"><span class="lineno">  252</span>        };</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a6ea78e52dff286b9309465a9b0f993a4a1c067a9fa89e2bf1d6dd55a6ca6204ce"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a1c067a9fa89e2bf1d6dd55a6ca6204ce">utility_module::convert_string::encoding_types::utf32</a></div><div class="ttdeci">@ utf32</div><div class="ttdoc">UTF-32 encoding.</div></div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">utility_module::convert_string::encoding_types::utf8</a></div><div class="ttdeci">@ utf8</div><div class="ttdoc">UTF-8 encoding.</div></div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a6ea78e52dff286b9309465a9b0f993a4a5ab39c2bd546655547f6101ed91e395e"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a5ab39c2bd546655547f6101ed91e395e">utility_module::convert_string::encoding_types::utf16</a></div><div class="ttdeci">@ utf16</div><div class="ttdoc">UTF-16 encoding.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afbde2f9b7be55d89662baedd43ba63cf" name="afbde2f9b7be55d89662baedd43ba63cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbde2f9b7be55d89662baedd43ba63cf">&#9670;&#160;</a></span>endian_types</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">utility_module::convert_string::endian_types</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible endianness values for UTF-16 or UTF-32 data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114" name="afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114"></a>little&#160;</td><td class="fielddoc"><p>Little-endian. </p>
</td></tr>
<tr><td class="fieldname"><a id="afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4" name="afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4"></a>big&#160;</td><td class="fielddoc"><p>Big-endian. </p>
</td></tr>
<tr><td class="fieldname"><a id="afbde2f9b7be55d89662baedd43ba63cfaad921d60486366258809553a3db49a4a" name="afbde2f9b7be55d89662baedd43ba63cfaad921d60486366258809553a3db49a4a"></a>unknown&#160;</td><td class="fielddoc"><p>Unknown or not applicable. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d1/d46/convert__string_8h_source.html#l00239">239</a> of file <a class="el" href="../../d1/d46/convert__string_8h_source.html">convert_string.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  240</span>        {</div>
<div class="line"><span class="lineno">  241</span>            <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">little</a>, </div>
<div class="line"><span class="lineno">  242</span>            <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4">big</a>,    </div>
<div class="line"><span class="lineno">  243</span>            <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaad921d60486366258809553a3db49a4a">unknown</a> </div>
<div class="line"><span class="lineno">  244</span>        };</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">utility_module::convert_string::endian_types::little</a></div><div class="ttdeci">@ little</div><div class="ttdoc">Little-endian.</div></div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_afbde2f9b7be55d89662baedd43ba63cfaad921d60486366258809553a3db49a4a"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaad921d60486366258809553a3db49a4a">utility_module::convert_string::endian_types::unknown</a></div><div class="ttdeci">@ unknown</div><div class="ttdoc">Unknown or not applicable.</div></div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4">utility_module::convert_string::endian_types::big</a></div><div class="ttdeci">@ big</div><div class="ttdoc">Big-endian.</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3886358e768fe8b41226184e21e9eaa9" name="a3886358e768fe8b41226184e21e9eaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3886358e768fe8b41226184e21e9eaa9">&#9670;&#160;</a></span>add_utf8_bom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::add_utf8_bom </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a UTF-8 BOM to a string if it doesn't already have one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input string (UTF-8 encoded). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string guaranteed to have the UTF-8 BOM at the start. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00267">267</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  268</span>    {</div>
<div class="line"><span class="lineno">  269</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#ae78b53cb309a989bbc39ffbbcb73054b">has_utf8_bom</a>(str) ? str : std::string(<span class="stringliteral">&quot;\xEF\xBB\xBF&quot;</span>) + str;</div>
<div class="line"><span class="lineno">  270</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_ae78b53cb309a989bbc39ffbbcb73054b"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#ae78b53cb309a989bbc39ffbbcb73054b">utility_module::convert_string::has_utf8_bom</a></div><div class="ttdeci">static auto has_utf8_bom(const std::string &amp;value) -&gt; bool</div><div class="ttdoc">Checks if a string has a UTF-8 BOM (Byte Order Mark).</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00255">convert_string.cpp:255</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a486c32b21f68395d8ecc2f96b49b2fcf" name="a486c32b21f68395d8ecc2f96b49b2fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486c32b21f68395d8ecc2f96b49b2fcf">&#9670;&#160;</a></span>base64_decode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::base64_decode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base64_str</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::vector&lt;uint8_t&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a Base64 string into a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base64_str</td><td>The Base64 string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of:<ul>
<li><code>std::vector&lt;uint8_t&gt;</code>: The decoded bytes (empty on failure).</li>
<li><code>std::optional&lt;std::string&gt;</code>: An error message if decoding fails, otherwise <code>std::nullopt</code>. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00461">461</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  463</span>    {</div>
<div class="line"><span class="lineno">  464</span>        <span class="keyword">static</span> <span class="keyword">const</span> std::string base64_chars = <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></div>
<div class="line"><span class="lineno">  465</span>                                                <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></div>
<div class="line"><span class="lineno">  466</span>                                                <span class="stringliteral">&quot;0123456789+/&quot;</span>;</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span>        <span class="keywordflow">if</span> (base64_str.length() % 4 != 0)</div>
<div class="line"><span class="lineno">  469</span>        {</div>
<div class="line"><span class="lineno">  470</span>            <span class="keywordflow">return</span> { std::vector&lt;uint8_t&gt;(), <span class="stringliteral">&quot;Invalid base64 input length&quot;</span> };</div>
<div class="line"><span class="lineno">  471</span>        }</div>
<div class="line"><span class="lineno">  472</span> </div>
<div class="line"><span class="lineno">  473</span>        <span class="keywordtype">size_t</span> padding = 0;</div>
<div class="line"><span class="lineno">  474</span>        <span class="keywordflow">if</span> (!base64_str.empty())</div>
<div class="line"><span class="lineno">  475</span>        {</div>
<div class="line"><span class="lineno">  476</span>            <span class="keywordflow">if</span> (base64_str[base64_str.length() - 1] == <span class="charliteral">&#39;=&#39;</span>)</div>
<div class="line"><span class="lineno">  477</span>                padding++;</div>
<div class="line"><span class="lineno">  478</span>            <span class="keywordflow">if</span> (base64_str.length() &gt;= 2 &amp;&amp; base64_str[base64_str.length() - 2] == <span class="charliteral">&#39;=&#39;</span>)</div>
<div class="line"><span class="lineno">  479</span>                padding++;</div>
<div class="line"><span class="lineno">  480</span>            <span class="keywordflow">if</span> (padding &gt; 2)</div>
<div class="line"><span class="lineno">  481</span>            {</div>
<div class="line"><span class="lineno">  482</span>                <span class="keywordflow">return</span> { std::vector&lt;uint8_t&gt;(), <span class="stringliteral">&quot;Invalid padding in base64 string&quot;</span> };</div>
<div class="line"><span class="lineno">  483</span>            }</div>
<div class="line"><span class="lineno">  484</span>        }</div>
<div class="line"><span class="lineno">  485</span> </div>
<div class="line"><span class="lineno">  486</span>        <span class="keywordtype">size_t</span> decoded_length = (base64_str.length() / 4) * 3 - padding;</div>
<div class="line"><span class="lineno">  487</span>        std::vector&lt;uint8_t&gt; decoded_data;</div>
<div class="line"><span class="lineno">  488</span>        decoded_data.reserve(decoded_length);</div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>        std::vector&lt;int&gt; decoding_table(256, -1);</div>
<div class="line"><span class="lineno">  491</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 64; i++)</div>
<div class="line"><span class="lineno">  492</span>        {</div>
<div class="line"><span class="lineno">  493</span>            decoding_table[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(base64_chars[<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(i)])] = i;</div>
<div class="line"><span class="lineno">  494</span>        }</div>
<div class="line"><span class="lineno">  495</span> </div>
<div class="line"><span class="lineno">  496</span>        uint32_t buffer = 0;</div>
<div class="line"><span class="lineno">  497</span>        <span class="keywordtype">int</span> bits_collected = 0;</div>
<div class="line"><span class="lineno">  498</span>        <span class="keywordtype">size_t</span> i = 0;</div>
<div class="line"><span class="lineno">  499</span>        <span class="keywordflow">for</span> (; i &lt; base64_str.length(); ++i)</div>
<div class="line"><span class="lineno">  500</span>        {</div>
<div class="line"><span class="lineno">  501</span>            <span class="keywordtype">char</span> c = base64_str[i];</div>
<div class="line"><span class="lineno">  502</span>            <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;=&#39;</span>)</div>
<div class="line"><span class="lineno">  503</span>            {</div>
<div class="line"><span class="lineno">  504</span>                <span class="keywordflow">if</span> (i &lt; base64_str.length() - padding)</div>
<div class="line"><span class="lineno">  505</span>                {</div>
<div class="line"><span class="lineno">  506</span>                    <span class="keywordflow">return</span> { std::vector&lt;uint8_t&gt;(), <span class="stringliteral">&quot;Invalid padding position in base64 string&quot;</span> };</div>
<div class="line"><span class="lineno">  507</span>                }</div>
<div class="line"><span class="lineno">  508</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  509</span>            }</div>
<div class="line"><span class="lineno">  510</span> </div>
<div class="line"><span class="lineno">  511</span>            <span class="keywordflow">if</span> (decoding_table[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(c)] == -1)</div>
<div class="line"><span class="lineno">  512</span>            {</div>
<div class="line"><span class="lineno">  513</span>                <span class="keywordflow">return</span> { std::vector&lt;uint8_t&gt;(), <span class="stringliteral">&quot;Invalid character in base64 string&quot;</span> };</div>
<div class="line"><span class="lineno">  514</span>            }</div>
<div class="line"><span class="lineno">  515</span> </div>
<div class="line"><span class="lineno">  516</span>            buffer = (buffer &lt;&lt; 6) | static_cast&lt;uint32_t&gt;(decoding_table[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(c)]);</div>
<div class="line"><span class="lineno">  517</span>            bits_collected += 6;</div>
<div class="line"><span class="lineno">  518</span> </div>
<div class="line"><span class="lineno">  519</span>            <span class="keywordflow">if</span> (bits_collected &gt;= 8)</div>
<div class="line"><span class="lineno">  520</span>            {</div>
<div class="line"><span class="lineno">  521</span>                bits_collected -= 8;</div>
<div class="line"><span class="lineno">  522</span>                decoded_data.push_back((buffer &gt;&gt; bits_collected) &amp; 0xFF);</div>
<div class="line"><span class="lineno">  523</span>            }</div>
<div class="line"><span class="lineno">  524</span>        }</div>
<div class="line"><span class="lineno">  525</span> </div>
<div class="line"><span class="lineno">  526</span>        <span class="keywordflow">for</span> (; i &lt; base64_str.length(); ++i)</div>
<div class="line"><span class="lineno">  527</span>        {</div>
<div class="line"><span class="lineno">  528</span>            <span class="keywordflow">if</span> (base64_str[i] != <span class="charliteral">&#39;=&#39;</span>)</div>
<div class="line"><span class="lineno">  529</span>            {</div>
<div class="line"><span class="lineno">  530</span>                <span class="keywordflow">return</span> { std::vector&lt;uint8_t&gt;(),</div>
<div class="line"><span class="lineno">  531</span>                         <span class="stringliteral">&quot;Invalid character after padding in base64 string&quot;</span> };</div>
<div class="line"><span class="lineno">  532</span>            }</div>
<div class="line"><span class="lineno">  533</span>        }</div>
<div class="line"><span class="lineno">  534</span> </div>
<div class="line"><span class="lineno">  535</span>        <span class="keywordflow">return</span> { decoded_data, std::nullopt };</div>
<div class="line"><span class="lineno">  536</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a30592e4ca22ebe9b45f847e7d4eed464" name="a30592e4ca22ebe9b45f847e7d4eed464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30592e4ca22ebe9b45f847e7d4eed464">&#9670;&#160;</a></span>base64_encode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::base64_encode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> -&gt; std::string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes a byte array into a Base64 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The raw byte array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Base64-encoded representation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00427">427</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  428</span>    {</div>
<div class="line"><span class="lineno">  429</span>        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> base64_chars[] = <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></div>
<div class="line"><span class="lineno">  430</span>                                           <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></div>
<div class="line"><span class="lineno">  431</span>                                           <span class="stringliteral">&quot;0123456789+/&quot;</span>;</div>
<div class="line"><span class="lineno">  432</span> </div>
<div class="line"><span class="lineno">  433</span>        std::string encoded_string;</div>
<div class="line"><span class="lineno">  434</span>        <span class="keywordtype">size_t</span> i = 0;</div>
<div class="line"><span class="lineno">  435</span>        uint32_t octet_a, octet_b, octet_c;</div>
<div class="line"><span class="lineno">  436</span>        uint32_t triple;</div>
<div class="line"><span class="lineno">  437</span> </div>
<div class="line"><span class="lineno">  438</span>        <span class="keywordflow">while</span> (i &lt; data.size())</div>
<div class="line"><span class="lineno">  439</span>        {</div>
<div class="line"><span class="lineno">  440</span>            octet_a = i &lt; data.size() ? data[i++] : 0;</div>
<div class="line"><span class="lineno">  441</span>            octet_b = i &lt; data.size() ? data[i++] : 0;</div>
<div class="line"><span class="lineno">  442</span>            octet_c = i &lt; data.size() ? data[i++] : 0;</div>
<div class="line"><span class="lineno">  443</span> </div>
<div class="line"><span class="lineno">  444</span>            triple = (octet_a &lt;&lt; 16) + (octet_b &lt;&lt; 8) + octet_c;</div>
<div class="line"><span class="lineno">  445</span> </div>
<div class="line"><span class="lineno">  446</span>            encoded_string += base64_chars[(triple &gt;&gt; 18) &amp; 0x3F];</div>
<div class="line"><span class="lineno">  447</span>            encoded_string += base64_chars[(triple &gt;&gt; 12) &amp; 0x3F];</div>
<div class="line"><span class="lineno">  448</span>            encoded_string += base64_chars[(triple &gt;&gt; 6) &amp; 0x3F];</div>
<div class="line"><span class="lineno">  449</span>            encoded_string += base64_chars[triple &amp; 0x3F];</div>
<div class="line"><span class="lineno">  450</span>        }</div>
<div class="line"><span class="lineno">  451</span> </div>
<div class="line"><span class="lineno">  452</span>        <span class="keywordtype">int</span> mod_table[] = { 0, 2, 1 };</div>
<div class="line"><span class="lineno">  453</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; mod_table[data.size() % 3]; j++)</div>
<div class="line"><span class="lineno">  454</span>        {</div>
<div class="line"><span class="lineno">  455</span>            encoded_string[encoded_string.size() - 1 - <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(j)] = <span class="charliteral">&#39;=&#39;</span>;</div>
<div class="line"><span class="lineno">  456</span>        }</div>
<div class="line"><span class="lineno">  457</span> </div>
<div class="line"><span class="lineno">  458</span>        <span class="keywordflow">return</span> encoded_string;</div>
<div class="line"><span class="lineno">  459</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abd95bc09617a96479dfb71d15869dd43" name="abd95bc09617a96479dfb71d15869dd43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd95bc09617a96479dfb71d15869dd43">&#9670;&#160;</a></span>convert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FromType , typename ToType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::convert </td>
          <td>(</td>
          <td class="paramtype">const FromType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from_encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to_encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;std::optional&lt;ToType&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from one encoding to another using <code>iconv</code> or equivalent APIs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FromType</td><td>The input string type. </td></tr>
    <tr><td class="paramname">ToType</td><td>The output string type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input string. </td></tr>
    <tr><td class="paramname">from_encoding</td><td>Source encoding name (e.g., "UTF-16LE"). </td></tr>
    <tr><td class="paramname">to_encoding</td><td>Target encoding name (e.g., "UTF-8"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple:<ul>
<li><code>std::optional&lt;ToType&gt;</code>: The converted string on success, or <code>std::nullopt</code> on failure.</li>
<li><code>std::optional&lt;std::string&gt;</code>: The error message if conversion fails. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00048">48</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   52</span>    {</div>
<div class="line"><span class="lineno">   53</span>        iconv_t cd = iconv_open(to_encoding.c_str(), from_encoding.c_str());</div>
<div class="line"><span class="lineno">   54</span>        <span class="keywordflow">if</span> (cd == (iconv_t)-1)</div>
<div class="line"><span class="lineno">   55</span>        {</div>
<div class="line"><span class="lineno">   56</span>            <span class="keywordflow">return</span> { std::nullopt, <span class="stringliteral">&quot;iconv_open failed: &quot;</span> + std::string(strerror(errno)) };</div>
<div class="line"><span class="lineno">   57</span>        }</div>
<div class="line"><span class="lineno">   58</span> </div>
<div class="line"><span class="lineno">   59</span>        std::vector&lt;char&gt; in_buf = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#aff4cf9e1164a4cb47d032b1d4f1caaad">string_to_vector</a>(value);</div>
<div class="line"><span class="lineno">   60</span>        <span class="keywordtype">char</span>* in_ptr = in_buf.data();</div>
<div class="line"><span class="lineno">   61</span>        <span class="keywordtype">size_t</span> in_bytes_left = in_buf.size();</div>
<div class="line"><span class="lineno">   62</span> </div>
<div class="line"><span class="lineno">   63</span>        <span class="keywordtype">size_t</span> out_buf_size = in_bytes_left * 2;</div>
<div class="line"><span class="lineno">   64</span>        std::vector&lt;char&gt; out_buf(out_buf_size);</div>
<div class="line"><span class="lineno">   65</span>        <span class="keywordtype">char</span>* out_ptr = out_buf.data();</div>
<div class="line"><span class="lineno">   66</span>        <span class="keywordtype">size_t</span> out_bytes_left = out_buf.size();</div>
<div class="line"><span class="lineno">   67</span> </div>
<div class="line"><span class="lineno">   68</span>        <span class="keywordtype">size_t</span> result = iconv(cd, &amp;in_ptr, &amp;in_bytes_left, &amp;out_ptr, &amp;out_bytes_left);</div>
<div class="line"><span class="lineno">   69</span>        <span class="keywordflow">while</span> (result == (<span class="keywordtype">size_t</span>)-1 &amp;&amp; errno == E2BIG)</div>
<div class="line"><span class="lineno">   70</span>        {</div>
<div class="line"><span class="lineno">   71</span>            <span class="keywordtype">size_t</span> used = out_buf_size - out_bytes_left;</div>
<div class="line"><span class="lineno">   72</span>            out_buf_size *= 2;</div>
<div class="line"><span class="lineno">   73</span>            out_buf.resize(out_buf_size);</div>
<div class="line"><span class="lineno">   74</span>            out_ptr = out_buf.data() + used;</div>
<div class="line"><span class="lineno">   75</span>            out_bytes_left = out_buf_size - used;</div>
<div class="line"><span class="lineno">   76</span>            result = iconv(cd, &amp;in_ptr, &amp;in_bytes_left, &amp;out_ptr, &amp;out_bytes_left);</div>
<div class="line"><span class="lineno">   77</span>        }</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>        <span class="keywordflow">if</span> (result == (<span class="keywordtype">size_t</span>)-1)</div>
<div class="line"><span class="lineno">   80</span>        {</div>
<div class="line"><span class="lineno">   81</span>            std::string error_msg = <span class="stringliteral">&quot;iconv failed: &quot;</span> + std::string(strerror(errno));</div>
<div class="line"><span class="lineno">   82</span>            iconv_close(cd);</div>
<div class="line"><span class="lineno">   83</span>            <span class="keywordflow">return</span> { std::nullopt, error_msg };</div>
<div class="line"><span class="lineno">   84</span>        }</div>
<div class="line"><span class="lineno">   85</span> </div>
<div class="line"><span class="lineno">   86</span>        iconv_close(cd);</div>
<div class="line"><span class="lineno">   87</span> </div>
<div class="line"><span class="lineno">   88</span>        <span class="keywordtype">size_t</span> converted_size = out_buf_size - out_bytes_left;</div>
<div class="line"><span class="lineno">   89</span>        ToType converted_string(<span class="keyword">reinterpret_cast&lt;</span>typename ToType::value_type*<span class="keyword">&gt;</span>(out_buf.data()),</div>
<div class="line"><span class="lineno">   90</span>                                converted_size / <span class="keyword">sizeof</span>(<span class="keyword">typename</span> ToType::value_type));</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span>        <span class="keywordflow">return</span> { converted_string, std::nullopt };</div>
<div class="line"><span class="lineno">   93</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_aff4cf9e1164a4cb47d032b1d4f1caaad"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#aff4cf9e1164a4cb47d032b1d4f1caaad">utility_module::convert_string::string_to_vector</a></div><div class="ttdeci">static auto string_to_vector(const T &amp;value) -&gt; std::vector&lt; char &gt;</div><div class="ttdoc">Converts a string (or wide string) to a std::vector&lt;char&gt; for iconv processing.</div><div class="ttdef"><b>Definition</b> <a href="../../d1/d46/convert__string_8h_source.html#l00283">convert_string.h:283</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa9caabbf474f464993f50e7d48e09a89" name="aa9caabbf474f464993f50e7d48e09a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9caabbf474f464993f50e7d48e09a89">&#9670;&#160;</a></span>detect_endian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::detect_endian </td>
          <td>(</td>
          <td class="paramtype">const std::u16string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects the endianness of a UTF-16 string by checking for BOM or content patterns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The UTF-16 string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The detected endianness (little, big, or unknown). </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00197">197</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  198</span>    {</div>
<div class="line"><span class="lineno">  199</span>        <span class="keywordflow">if</span> (str.empty())</div>
<div class="line"><span class="lineno">  200</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaad921d60486366258809553a3db49a4a">endian_types::unknown</a>;</div>
<div class="line"><span class="lineno">  201</span> </div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">if</span> (str[0] == 0xFEFF)</div>
<div class="line"><span class="lineno">  203</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4">endian_types::big</a>;</div>
<div class="line"><span class="lineno">  204</span>        <span class="keywordflow">if</span> (str[0] == 0xFFFE)</div>
<div class="line"><span class="lineno">  205</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>;</div>
<div class="line"><span class="lineno">  206</span> </div>
<div class="line"><span class="lineno">  207</span>        <span class="keywordtype">size_t</span> sample_size = std::min&lt;size_t&gt;(str.size(), 1000);</div>
<div class="line"><span class="lineno">  208</span>        <span class="keywordtype">int</span> le_count = 0, be_count = 0;</div>
<div class="line"><span class="lineno">  209</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; sample_size; ++i)</div>
<div class="line"><span class="lineno">  210</span>        {</div>
<div class="line"><span class="lineno">  211</span>            uint16_t ch = str[i];</div>
<div class="line"><span class="lineno">  212</span>            <span class="keywordflow">if</span> ((ch &amp; 0xFF00) == 0 &amp;&amp; (ch &amp; 0x00FF) != 0)</div>
<div class="line"><span class="lineno">  213</span>                ++le_count;</div>
<div class="line"><span class="lineno">  214</span>            <span class="keywordflow">if</span> ((ch &amp; 0x00FF) == 0 &amp;&amp; (ch &amp; 0xFF00) != 0)</div>
<div class="line"><span class="lineno">  215</span>                ++be_count;</div>
<div class="line"><span class="lineno">  216</span>        }</div>
<div class="line"><span class="lineno">  217</span> </div>
<div class="line"><span class="lineno">  218</span>        <span class="keywordflow">if</span> (le_count &gt; be_count)</div>
<div class="line"><span class="lineno">  219</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>;</div>
<div class="line"><span class="lineno">  220</span>        <span class="keywordflow">if</span> (be_count &gt; le_count)</div>
<div class="line"><span class="lineno">  221</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4">endian_types::big</a>;</div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaad921d60486366258809553a3db49a4a">endian_types::unknown</a>;</div>
<div class="line"><span class="lineno">  224</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae97a673c0e90ad30e5fee349f7112f52" name="ae97a673c0e90ad30e5fee349f7112f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97a673c0e90ad30e5fee349f7112f52">&#9670;&#160;</a></span>detect_endian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::detect_endian </td>
          <td>(</td>
          <td class="paramtype">const std::u32string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects the endianness of a UTF-32 string by checking for BOM or content patterns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The UTF-32 string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The detected endianness (little, big, or unknown). </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00226">226</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  227</span>    {</div>
<div class="line"><span class="lineno">  228</span>        <span class="keywordflow">if</span> (str.empty())</div>
<div class="line"><span class="lineno">  229</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaad921d60486366258809553a3db49a4a">endian_types::unknown</a>;</div>
<div class="line"><span class="lineno">  230</span> </div>
<div class="line"><span class="lineno">  231</span>        <span class="keywordflow">if</span> (str[0] == 0x0000FEFF)</div>
<div class="line"><span class="lineno">  232</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4">endian_types::big</a>;</div>
<div class="line"><span class="lineno">  233</span>        <span class="keywordflow">if</span> (str[0] == 0xFFFE0000)</div>
<div class="line"><span class="lineno">  234</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>;</div>
<div class="line"><span class="lineno">  235</span> </div>
<div class="line"><span class="lineno">  236</span>        <span class="keywordtype">size_t</span> sample_size = std::min&lt;size_t&gt;(str.size(), 1000);</div>
<div class="line"><span class="lineno">  237</span>        <span class="keywordtype">int</span> le_count = 0, be_count = 0;</div>
<div class="line"><span class="lineno">  238</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; sample_size; ++i)</div>
<div class="line"><span class="lineno">  239</span>        {</div>
<div class="line"><span class="lineno">  240</span>            uint32_t ch = str[i];</div>
<div class="line"><span class="lineno">  241</span>            <span class="keywordflow">if</span> ((ch &amp; 0xFFFFFF00) == 0 &amp;&amp; (ch &amp; 0x000000FF) != 0)</div>
<div class="line"><span class="lineno">  242</span>                ++le_count;</div>
<div class="line"><span class="lineno">  243</span>            <span class="keywordflow">if</span> ((ch &amp; 0x00FFFFFF) == 0 &amp;&amp; (ch &amp; 0xFF000000) != 0)</div>
<div class="line"><span class="lineno">  244</span>                ++be_count;</div>
<div class="line"><span class="lineno">  245</span>        }</div>
<div class="line"><span class="lineno">  246</span> </div>
<div class="line"><span class="lineno">  247</span>        <span class="keywordflow">if</span> (le_count &gt; be_count)</div>
<div class="line"><span class="lineno">  248</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>;</div>
<div class="line"><span class="lineno">  249</span>        <span class="keywordflow">if</span> (be_count &gt; le_count)</div>
<div class="line"><span class="lineno">  250</span>            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4">endian_types::big</a>;</div>
<div class="line"><span class="lineno">  251</span> </div>
<div class="line"><span class="lineno">  252</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaad921d60486366258809553a3db49a4a">endian_types::unknown</a>;</div>
<div class="line"><span class="lineno">  253</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a118786eba66d84cd2a02c911775141ec" name="a118786eba66d84cd2a02c911775141ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118786eba66d84cd2a02c911775141ec">&#9670;&#160;</a></span>from_base64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::from_base64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base64_str</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::vector&lt;uint8_t&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a Base64 string into a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base64_str</td><td>The Base64-encoded string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of:<ul>
<li><code>std::vector&lt;uint8_t&gt;</code>: The decoded data. May be empty if decoding fails.</li>
<li><code>std::optional&lt;std::string&gt;</code>: An error message on failure, or <code>std::nullopt</code> on success. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00377">377</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  379</span>    {</div>
<div class="line"><span class="lineno">  380</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a486c32b21f68395d8ecc2f96b49b2fcf">base64_decode</a>(base64_str);</div>
<div class="line"><span class="lineno">  381</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a486c32b21f68395d8ecc2f96b49b2fcf"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a486c32b21f68395d8ecc2f96b49b2fcf">utility_module::convert_string::base64_decode</a></div><div class="ttdeci">static auto base64_decode(const std::string &amp;base64_str) -&gt; std::tuple&lt; std::vector&lt; uint8_t &gt;, std::optional&lt; std::string &gt; &gt;</div><div class="ttdoc">Decodes a Base64 string into a byte array.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00461">convert_string.cpp:461</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8d073801a85c823fefc5f2c00e40a2f5" name="a8d073801a85c823fefc5f2c00e40a2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d073801a85c823fefc5f2c00e40a2f5">&#9670;&#160;</a></span>get_code_page_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::get_code_page_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code_page</em></td><td>)</td>
          <td> -&gt; std::string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a textual name for a code page (e.g., "CP_ACP" or a locale-based name). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code_page</td><td>The code page integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the code page name, or an empty string if unknown. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00281">281</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  282</span>    {</div>
<div class="line"><span class="lineno">  283</span>        <span class="keywordflow">switch</span> (code_page)</div>
<div class="line"><span class="lineno">  284</span>        {</div>
<div class="line"><span class="lineno">  285</span>        <span class="keywordflow">case</span> 65001:</div>
<div class="line"><span class="lineno">  286</span>            <span class="keywordflow">return</span> <span class="stringliteral">&quot;UTF-8&quot;</span>;</div>
<div class="line"><span class="lineno">  287</span>        <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  288</span>            <span class="keywordflow">return</span> <span class="stringliteral">&quot;CP&quot;</span> + std::to_string(code_page);</div>
<div class="line"><span class="lineno">  289</span>        }</div>
<div class="line"><span class="lineno">  290</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a316651c671cec003dc927423e12d2466" name="a316651c671cec003dc927423e12d2466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316651c671cec003dc927423e12d2466">&#9670;&#160;</a></span>get_encoding_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::get_encoding_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4">encoding_types</a>&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a>&#160;</td>
          <td class="paramname"><em>endian</em> = <code><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the encoding name used by iconv based on <code>encoding</code> and <code>endian</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>The base encoding (UTF-8, UTF-16, or UTF-32). </td></tr>
    <tr><td class="paramname">endian</td><td>The byte order (little, big) if applicable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string recognized by iconv, such as "UTF-8" or "UTF-16LE". </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00155">155</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  157</span>    {</div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">switch</span> (encoding)</div>
<div class="line"><span class="lineno">  159</span>        {</div>
<div class="line"><span class="lineno">  160</span>        <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">encoding_types::utf8</a>:</div>
<div class="line"><span class="lineno">  161</span>            <span class="keywordflow">return</span> <span class="stringliteral">&quot;UTF-8&quot;</span>;</div>
<div class="line"><span class="lineno">  162</span>        <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a5ab39c2bd546655547f6101ed91e395e">encoding_types::utf16</a>:</div>
<div class="line"><span class="lineno">  163</span>            <span class="keywordflow">if</span> (endian == <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>)</div>
<div class="line"><span class="lineno">  164</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;UTF-16LE&quot;</span>;</div>
<div class="line"><span class="lineno">  165</span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (endian == <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4">endian_types::big</a>)</div>
<div class="line"><span class="lineno">  166</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;UTF-16BE&quot;</span>;</div>
<div class="line"><span class="lineno">  167</span>            <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  168</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;UTF-16&quot;</span>;</div>
<div class="line"><span class="lineno">  169</span>        <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a1c067a9fa89e2bf1d6dd55a6ca6204ce">encoding_types::utf32</a>:</div>
<div class="line"><span class="lineno">  170</span>            <span class="keywordflow">if</span> (endian == <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>)</div>
<div class="line"><span class="lineno">  171</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;UTF-32LE&quot;</span>;</div>
<div class="line"><span class="lineno">  172</span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (endian == <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfad861877da56b8b4ceb35c8cbfdf65bb4">endian_types::big</a>)</div>
<div class="line"><span class="lineno">  173</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;UTF-32BE&quot;</span>;</div>
<div class="line"><span class="lineno">  174</span>            <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  175</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;UTF-32&quot;</span>;</div>
<div class="line"><span class="lineno">  176</span>        <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  177</span>            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unknown encoding&quot;</span>);</div>
<div class="line"><span class="lineno">  178</span>        }</div>
<div class="line"><span class="lineno">  179</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a72c39f9c977f20e433d4f1ddc13a3eb5" name="a72c39f9c977f20e433d4f1ddc13a3eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c39f9c977f20e433d4f1ddc13a3eb5">&#9670;&#160;</a></span>get_system_code_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::get_system_code_page </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the system code page used for conversions. </p>
<dl class="section return"><dt>Returns</dt><dd>An integer representing the system code page (e.g., CP_ACP on Windows).</dd></dl>
<p>On Unix-like systems using <code>iconv</code>, this may return an approximation based on locale info, or a default if detection fails. </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00272">272</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  273</span>    {</div>
<div class="line"><span class="lineno">  274</span><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="lineno">  275</span>        <span class="keywordflow">return</span> GetACP();</div>
<div class="line"><span class="lineno">  276</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  277</span>        <span class="keywordflow">return</span> 65001;</div>
<div class="line"><span class="lineno">  278</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  279</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a445b122955236c6ca960ac541810a3d2" name="a445b122955236c6ca960ac541810a3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445b122955236c6ca960ac541810a3d2">&#9670;&#160;</a></span>get_wchar_encoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::get_wchar_encoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a>&#160;</td>
          <td class="paramname"><em>endian</em> = <code><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a></code></td><td>)</td>
          <td> -&gt; std::string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derives the wchar_t encoding name based on its size and endianness. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endian</td><td>The byte order. Defaults to little-endian. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For example, "UTF-16LE" on Windows or "UTF-32LE" on some Unix-like systems. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00181">181</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  182</span>    {</div>
<div class="line"><span class="lineno">  183</span>        <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 2)</div>
<div class="line"><span class="lineno">  184</span>        {</div>
<div class="line"><span class="lineno">  185</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a316651c671cec003dc927423e12d2466">get_encoding_name</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a5ab39c2bd546655547f6101ed91e395e">encoding_types::utf16</a>, endian);</div>
<div class="line"><span class="lineno">  186</span>        }</div>
<div class="line"><span class="lineno">  187</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 4)</div>
<div class="line"><span class="lineno">  188</span>        {</div>
<div class="line"><span class="lineno">  189</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a316651c671cec003dc927423e12d2466">get_encoding_name</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a1c067a9fa89e2bf1d6dd55a6ca6204ce">encoding_types::utf32</a>, endian);</div>
<div class="line"><span class="lineno">  190</span>        }</div>
<div class="line"><span class="lineno">  191</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  192</span>        {</div>
<div class="line"><span class="lineno">  193</span>            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unsupported wchar_t size&quot;</span>);</div>
<div class="line"><span class="lineno">  194</span>        }</div>
<div class="line"><span class="lineno">  195</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a316651c671cec003dc927423e12d2466"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a316651c671cec003dc927423e12d2466">utility_module::convert_string::get_encoding_name</a></div><div class="ttdeci">static auto get_encoding_name(encoding_types encoding, endian_types endian=endian_types::little) -&gt; std::string</div><div class="ttdoc">Determines the encoding name used by iconv based on encoding and endian.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00155">convert_string.cpp:155</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae78b53cb309a989bbc39ffbbcb73054b" name="ae78b53cb309a989bbc39ffbbcb73054b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78b53cb309a989bbc39ffbbcb73054b">&#9670;&#160;</a></span>has_utf8_bom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::has_utf8_bom </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a string has a UTF-8 BOM (Byte Order Mark). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input string (UTF-8 encoded). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string starts with the UTF-8 BOM (0xEF,0xBB,0xBF), else <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00255">255</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  256</span>    {</div>
<div class="line"><span class="lineno">  257</span>        <span class="keywordflow">return</span> str.length() &gt;= 3 &amp;&amp; <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(str[0]) == 0xEF</div>
<div class="line"><span class="lineno">  258</span>               &amp;&amp; <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(str[1]) == 0xBB</div>
<div class="line"><span class="lineno">  259</span>               &amp;&amp; <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(str[2]) == 0xBF;</div>
<div class="line"><span class="lineno">  260</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adfae97e9adf04f637025406457671f57" name="adfae97e9adf04f637025406457671f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfae97e9adf04f637025406457671f57">&#9670;&#160;</a></span>remove_utf8_bom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::remove_utf8_bom </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a leading UTF-8 BOM from a string, if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input string (UTF-8 encoded). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string without the BOM. If no BOM was present, returns the original string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00262">262</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  263</span>    {</div>
<div class="line"><span class="lineno">  264</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#ae78b53cb309a989bbc39ffbbcb73054b">has_utf8_bom</a>(str) ? str.substr(3) : str;</div>
<div class="line"><span class="lineno">  265</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af4f62dd34644ec32bead2a2826c85d79" name="af4f62dd34644ec32bead2a2826c85d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f62dd34644ec32bead2a2826c85d79">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::replace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::optional&lt;std::string&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of <code>token</code> in <code>source</code> with <code>target</code>, in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The string to modify. </td></tr>
    <tr><td class="paramname">token</td><td>The substring to find. </td></tr>
    <tr><td class="paramname">target</td><td>The substring to replace <code>token</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::optional&lt;std::string&gt;</code> containing an error message if replacement fails, or <code>std::nullopt</code> on success.</dd></dl>
<p>This function modifies <code>source</code> directly. If <code>token</code> is empty, it returns an error. </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00383">383</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  386</span>    {</div>
<div class="line"><span class="lineno">  387</span>        <span class="keyword">auto</span> [value, value_error] = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a735255ee06de6baa6f70ddd97b724402">replace2</a>(source, token, target);</div>
<div class="line"><span class="lineno">  388</span>        <span class="keywordflow">if</span> (value_error.has_value())</div>
<div class="line"><span class="lineno">  389</span>        {</div>
<div class="line"><span class="lineno">  390</span>            <span class="keywordflow">return</span> value_error;</div>
<div class="line"><span class="lineno">  391</span>        }</div>
<div class="line"><span class="lineno">  392</span> </div>
<div class="line"><span class="lineno">  393</span>        source = value.value();</div>
<div class="line"><span class="lineno">  394</span>        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line"><span class="lineno">  395</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a735255ee06de6baa6f70ddd97b724402"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a735255ee06de6baa6f70ddd97b724402">utility_module::convert_string::replace2</a></div><div class="ttdeci">static auto replace2(const std::string &amp;source, const std::string &amp;token, const std::string &amp;target) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</div><div class="ttdoc">Replaces all occurrences of token in source with target, returning a new string.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00397">convert_string.cpp:397</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a735255ee06de6baa6f70ddd97b724402" name="a735255ee06de6baa6f70ddd97b724402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735255ee06de6baa6f70ddd97b724402">&#9670;&#160;</a></span>replace2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::replace2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;std::optional&lt;std::string&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all occurrences of <code>token</code> in <code>source</code> with <code>target</code>, returning a new string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source string (unchanged). </td></tr>
    <tr><td class="paramname">token</td><td>The substring to find. </td></tr>
    <tr><td class="paramname">target</td><td>The substring to replace <code>token</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of:<ul>
<li><code>std::optional&lt;std::string&gt;</code>: The modified string on success.</li>
<li><code>std::optional&lt;std::string&gt;</code>: An error message if replacement fails. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00397">397</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  401</span>    {</div>
<div class="line"><span class="lineno">  402</span>        <span class="keywordflow">if</span> (source.empty())</div>
<div class="line"><span class="lineno">  403</span>        {</div>
<div class="line"><span class="lineno">  404</span>            <span class="keywordflow">return</span> { std::nullopt, <span class="stringliteral">&quot;Source string is empty&quot;</span> };</div>
<div class="line"><span class="lineno">  405</span>        }</div>
<div class="line"><span class="lineno">  406</span> </div>
<div class="line"><span class="lineno">  407</span>        <span class="keywordflow">if</span> (token.empty())</div>
<div class="line"><span class="lineno">  408</span>        {</div>
<div class="line"><span class="lineno">  409</span>            <span class="keywordflow">return</span> { std::nullopt, <span class="stringliteral">&quot;Token string is empty&quot;</span> };</div>
<div class="line"><span class="lineno">  410</span>        }</div>
<div class="line"><span class="lineno">  411</span> </div>
<div class="line"><span class="lineno">  412</span>        std::string result;</div>
<div class="line"><span class="lineno">  413</span> </div>
<div class="line"><span class="lineno">  414</span>        <span class="keywordtype">size_t</span> last_offset = 0;</div>
<div class="line"><span class="lineno">  415</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> offset = source.find(token, last_offset); offset != std::string::npos;</div>
<div class="line"><span class="lineno">  416</span>             last_offset = offset + token.size(), offset = source.find(token, last_offset))</div>
<div class="line"><span class="lineno">  417</span>        {</div>
<div class="line"><span class="lineno">  418</span>            <a class="code hl_function" href="../../d1/daf/classutility__module_1_1formatter.html#a12d7278310683404a3342631586528b6">formatter::format_to</a>(std::back_inserter(result), <span class="stringliteral">&quot;{}{}&quot;</span>,</div>
<div class="line"><span class="lineno">  419</span>                                 source.substr(last_offset, offset - last_offset), target);</div>
<div class="line"><span class="lineno">  420</span>        }</div>
<div class="line"><span class="lineno">  421</span> </div>
<div class="line"><span class="lineno">  422</span>        <a class="code hl_function" href="../../d1/daf/classutility__module_1_1formatter.html#a12d7278310683404a3342631586528b6">formatter::format_to</a>(std::back_inserter(result), <span class="stringliteral">&quot;{}&quot;</span>, source.substr(last_offset));</div>
<div class="line"><span class="lineno">  423</span> </div>
<div class="line"><span class="lineno">  424</span>        <span class="keywordflow">return</span> { result, std::nullopt };</div>
<div class="line"><span class="lineno">  425</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1formatter_html_a12d7278310683404a3342631586528b6"><div class="ttname"><a href="../../d1/daf/classutility__module_1_1formatter.html#a12d7278310683404a3342631586528b6">utility_module::formatter::format_to</a></div><div class="ttdeci">static auto format_to(OutputIt out, const char *formats, const FormatArgs &amp;... args) -&gt; OutputIt</div><div class="ttdoc">Formats a narrow-character string directly to an output iterator.</div><div class="ttdef"><b>Definition</b> <a href="../../de/d52/formatter_8h_source.html#l00287">formatter.h:287</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/d53/classutility__module_1_1convert__string_a735255ee06de6baa6f70ddd97b724402_cgraph.png" border="0" usemap="#ad1/d53/classutility__module_1_1convert__string_a735255ee06de6baa6f70ddd97b724402_cgraph" alt=""/></div>
<map name="ad1/d53/classutility__module_1_1convert__string_a735255ee06de6baa6f70ddd97b724402_cgraph" id="ad1/d53/classutility__module_1_1convert__string_a735255ee06de6baa6f70ddd97b724402_cgraph">
<area shape="rect" title="Replaces all occurrences of token in source with target, returning a new string." alt="" coords="5,5,179,45"/>
<area shape="rect" href="../../d1/daf/classutility__module_1_1formatter.html#a12d7278310683404a3342631586528b6" title="Formats a narrow&#45;character string directly to an output iterator." alt="" coords="227,5,413,45"/>
<area shape="poly" title=" " alt="" coords="179,23,213,23,213,28,179,28"/>
<area shape="rect" href="../../d1/daf/classutility__module_1_1formatter.html#a1b5ec167f6e47412edd77a4ea658e339" title="Formats a narrow&#45;character string with the given arguments." alt="" coords="461,5,648,45"/>
<area shape="poly" title=" " alt="" coords="413,23,448,23,448,28,413,28"/>
<area shape="rect" href="../../d1/daf/classutility__module_1_1formatter.html#a0e0cfc83510413df54bdf125abddbfbf" title=" " alt="" coords="696,5,883,45"/>
<area shape="poly" title=" " alt="" coords="648,31,682,32,682,37,648,37"/>
<area shape="poly" title=" " alt="" coords="696,19,661,19,661,14,696,14"/>
</map>
</div>

</div>
</div>
<a id="af38229e1d31f5460f04aad36890d6fde" name="af38229e1d31f5460f04aad36890d6fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38229e1d31f5460f04aad36890d6fde">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;std::optional&lt;std::vector&lt;std::string&gt;&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a string by a given delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source string to split. </td></tr>
    <tr><td class="paramname">token</td><td>The delimiter substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of:<ul>
<li><code>std::optional&lt;std::vector&lt;std::string&gt;&gt;</code>: A vector of tokens on success.</li>
<li><code>std::optional&lt;std::string&gt;</code>: An error message if splitting fails.</li>
</ul>
</dd></dl>
<p>If <code>token</code> is empty, splitting cannot proceed and an error is returned. </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00316">316</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  318</span>    {</div>
<div class="line"><span class="lineno">  319</span>        <span class="keywordflow">if</span> (token.empty())</div>
<div class="line"><span class="lineno">  320</span>        {</div>
<div class="line"><span class="lineno">  321</span>            <span class="keywordflow">return</span> { std::vector{ source }, std::nullopt };</div>
<div class="line"><span class="lineno">  322</span>        }</div>
<div class="line"><span class="lineno">  323</span> </div>
<div class="line"><span class="lineno">  324</span>        std::vector&lt;std::string&gt; result;</div>
<div class="line"><span class="lineno">  325</span>        <span class="keywordtype">size_t</span> start_pos = 0;</div>
<div class="line"><span class="lineno">  326</span>        <span class="keywordtype">size_t</span> end_pos = source.find(token);</div>
<div class="line"><span class="lineno">  327</span> </div>
<div class="line"><span class="lineno">  328</span>        <span class="keywordflow">while</span> (end_pos != std::string::npos)</div>
<div class="line"><span class="lineno">  329</span>        {</div>
<div class="line"><span class="lineno">  330</span>            result.emplace_back(source.substr(start_pos, end_pos - start_pos));</div>
<div class="line"><span class="lineno">  331</span>            start_pos = end_pos + token.length();</div>
<div class="line"><span class="lineno">  332</span>            end_pos = source.find(token, start_pos);</div>
<div class="line"><span class="lineno">  333</span>        }</div>
<div class="line"><span class="lineno">  334</span> </div>
<div class="line"><span class="lineno">  335</span>        result.emplace_back(source.substr(start_pos));</div>
<div class="line"><span class="lineno">  336</span> </div>
<div class="line"><span class="lineno">  337</span>        <span class="keywordflow">return</span> { result, std::nullopt };</div>
<div class="line"><span class="lineno">  338</span>    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/d53/classutility__module_1_1convert__string_af38229e1d31f5460f04aad36890d6fde_icgraph.png" border="0" usemap="#ad1/d53/classutility__module_1_1convert__string_af38229e1d31f5460f04aad36890d6fde_icgraph" alt=""/></div>
<map name="ad1/d53/classutility__module_1_1convert__string_af38229e1d31f5460f04aad36890d6fde_icgraph" id="ad1/d53/classutility__module_1_1convert__string_af38229e1d31f5460f04aad36890d6fde_icgraph">
<area shape="rect" title="Splits a string by a given delimiter." alt="" coords="240,5,413,45"/>
<area shape="rect" href="../../de/d30/classutility__module_1_1argument__manager.html#acc2ee37fee7956fa5b52a75e2e6f406e" title="Parse command&#45;line arguments from a single (possibly wide) string." alt="" coords="5,5,192,45"/>
<area shape="poly" title=" " alt="" coords="226,28,192,28,192,23,226,23"/>
</map>
</div>

</div>
</div>
<a id="aff4cf9e1164a4cb47d032b1d4f1caaad" name="aff4cf9e1164a4cb47d032b1d4f1caaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4cf9e1164a4cb47d032b1d4f1caaad">&#9670;&#160;</a></span>string_to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto utility_module::convert_string::string_to_vector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::vector&lt;char&gt;
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string (or wide string) to a <code>std::vector&lt;char&gt;</code> for iconv processing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type of the input string (char, wchar_t, char16_t, etc.). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the raw byte representation of <code>value</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d1/d46/convert__string_8h_source.html#l00283">283</a> of file <a class="el" href="../../d1/d46/convert__string_8h_source.html">convert_string.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  284</span>        {</div>
<div class="line"><span class="lineno">  285</span>            <span class="keywordflow">return</span> std::vector&lt;char&gt;(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(value.data()),</div>
<div class="line"><span class="lineno">  286</span>                                     <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(value.data() + value.size()));</div>
<div class="line"><span class="lineno">  287</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad30f587d85f8caf0bdcfddf109d60ce0" name="ad30f587d85f8caf0bdcfddf109d60ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30f587d85f8caf0bdcfddf109d60ce0">&#9670;&#160;</a></span>system_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::system_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::optional&lt;std::string&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a system-encoded string to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input string in system encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of:<ul>
<li><code>std::optional&lt;std::string&gt;</code>: The UTF-8 encoded string on success.</li>
<li><code>std::optional&lt;std::string&gt;</code>: An error message on failure. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00292">292</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  294</span>    {</div>
<div class="line"><span class="lineno">  295</span>        <span class="keywordtype">int</span> code_page = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a72c39f9c977f20e433d4f1ddc13a3eb5">get_system_code_page</a>();</div>
<div class="line"><span class="lineno">  296</span>        <span class="keywordflow">if</span> (code_page == 65001)</div>
<div class="line"><span class="lineno">  297</span>        {</div>
<div class="line"><span class="lineno">  298</span>            <span class="keywordflow">return</span> { value, std::nullopt };</div>
<div class="line"><span class="lineno">  299</span>        }</div>
<div class="line"><span class="lineno">  300</span>        <span class="keywordflow">return</span> convert&lt;std::string, std::string&gt;(value, <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a8d073801a85c823fefc5f2c00e40a2f5">get_code_page_name</a>(code_page),</div>
<div class="line"><span class="lineno">  301</span>                                                 <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a316651c671cec003dc927423e12d2466">get_encoding_name</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">encoding_types::utf8</a>));</div>
<div class="line"><span class="lineno">  302</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a72c39f9c977f20e433d4f1ddc13a3eb5"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a72c39f9c977f20e433d4f1ddc13a3eb5">utility_module::convert_string::get_system_code_page</a></div><div class="ttdeci">static auto get_system_code_page() -&gt; int</div><div class="ttdoc">Retrieves the system code page used for conversions.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00272">convert_string.cpp:272</a></div></div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a8d073801a85c823fefc5f2c00e40a2f5"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a8d073801a85c823fefc5f2c00e40a2f5">utility_module::convert_string::get_code_page_name</a></div><div class="ttdeci">static auto get_code_page_name(int code_page) -&gt; std::string</div><div class="ttdoc">Retrieves a textual name for a code page (e.g., &quot;CP_ACP&quot; or a locale-based name).</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00281">convert_string.cpp:281</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a774607516416d24843fce7ef3cb8d593" name="a774607516416d24843fce7ef3cb8d593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774607516416d24843fce7ef3cb8d593">&#9670;&#160;</a></span>to_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::to_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::optional&lt;std::vector&lt;uint8_t&gt;&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a system-encoded string to a UTF-8 byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input string in system encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of:<ul>
<li><code>std::optional&lt;std::vector&lt;uint8_t&gt;&gt;</code>: The UTF-8 byte array on success.</li>
<li><code>std::optional&lt;std::string&gt;</code>: An error message on failure. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00340">340</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  342</span>    {</div>
<div class="line"><span class="lineno">  343</span>        <span class="keyword">auto</span> [<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">utf8</a>, convert_error] = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#ad30f587d85f8caf0bdcfddf109d60ce0">system_to_utf8</a>(value);</div>
<div class="line"><span class="lineno">  344</span>        <span class="keywordflow">if</span> (convert_error.has_value())</div>
<div class="line"><span class="lineno">  345</span>        {</div>
<div class="line"><span class="lineno">  346</span>            <span class="keywordflow">return</span> { std::nullopt, convert_error };</div>
<div class="line"><span class="lineno">  347</span>        }</div>
<div class="line"><span class="lineno">  348</span> </div>
<div class="line"><span class="lineno">  349</span>        <span class="keyword">auto</span> utf8_no_bom = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#adfae97e9adf04f637025406457671f57">remove_utf8_bom</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">utf8</a>.value());</div>
<div class="line"><span class="lineno">  350</span> </div>
<div class="line"><span class="lineno">  351</span>        <span class="keywordflow">return</span> { std::vector&lt;uint8_t&gt;(utf8_no_bom.begin(), utf8_no_bom.end()), std::nullopt };</div>
<div class="line"><span class="lineno">  352</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_ad30f587d85f8caf0bdcfddf109d60ce0"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#ad30f587d85f8caf0bdcfddf109d60ce0">utility_module::convert_string::system_to_utf8</a></div><div class="ttdeci">static auto system_to_utf8(const std::string &amp;value) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</div><div class="ttdoc">Converts a system-encoded string to UTF-8.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00292">convert_string.cpp:292</a></div></div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_adfae97e9adf04f637025406457671f57"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#adfae97e9adf04f637025406457671f57">utility_module::convert_string::remove_utf8_bom</a></div><div class="ttdeci">static auto remove_utf8_bom(const std::string &amp;value) -&gt; std::string</div><div class="ttdoc">Removes a leading UTF-8 BOM from a string, if present.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00262">convert_string.cpp:262</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6cc64202472f47e2bf91bc607e8250a2" name="a6cc64202472f47e2bf91bc607e8250a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc64202472f47e2bf91bc607e8250a2">&#9670;&#160;</a></span>to_base64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::to_base64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::optional&lt;std::string&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes a byte array into a Base64 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The raw byte array to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of:<ul>
<li><code>std::optional&lt;std::string&gt;</code>: The Base64-encoded string on success.</li>
<li><code>std::optional&lt;std::string&gt;</code>: An error message if encoding fails.</li>
</ul>
</dd></dl>
<p>Typically, Base64 encoding should not fail unless the input is extremely large and memory allocation fails. </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00363">363</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  365</span>    {</div>
<div class="line"><span class="lineno">  366</span>        <span class="keywordflow">try</span></div>
<div class="line"><span class="lineno">  367</span>        {</div>
<div class="line"><span class="lineno">  368</span>            std::string encoded = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a30592e4ca22ebe9b45f847e7d4eed464">base64_encode</a>(value);</div>
<div class="line"><span class="lineno">  369</span>            <span class="keywordflow">return</span> { encoded, std::nullopt };</div>
<div class="line"><span class="lineno">  370</span>        }</div>
<div class="line"><span class="lineno">  371</span>        <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e)</div>
<div class="line"><span class="lineno">  372</span>        {</div>
<div class="line"><span class="lineno">  373</span>            <span class="keywordflow">return</span> { std::nullopt, e.what() };</div>
<div class="line"><span class="lineno">  374</span>        }</div>
<div class="line"><span class="lineno">  375</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a30592e4ca22ebe9b45f847e7d4eed464"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a30592e4ca22ebe9b45f847e7d4eed464">utility_module::convert_string::base64_encode</a></div><div class="ttdeci">static auto base64_encode(const std::vector&lt; uint8_t &gt; &amp;data) -&gt; std::string</div><div class="ttdoc">Encodes a byte array into a Base64 string.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00427">convert_string.cpp:427</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeaae4329ae07d19deada3f5d53d2fe9e" name="aeaae4329ae07d19deada3f5d53d2fe9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaae4329ae07d19deada3f5d53d2fe9e">&#9670;&#160;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::optional&lt;std::string&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a UTF-8 byte array to a system-encoded string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The input byte array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with:<ul>
<li><code>std::optional&lt;std::string&gt;</code>: The system-encoded string on success.</li>
<li><code>std::optional&lt;std::string&gt;</code>: An error message on failure. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00354">354</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  356</span>    {</div>
<div class="line"><span class="lineno">  357</span>        std::string <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">utf8</a>(value.begin(), value.end());</div>
<div class="line"><span class="lineno">  358</span>        <span class="keyword">auto</span> utf8_no_bom = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#adfae97e9adf04f637025406457671f57">remove_utf8_bom</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">utf8</a>);</div>
<div class="line"><span class="lineno">  359</span> </div>
<div class="line"><span class="lineno">  360</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#ae95c2d5708b124dc8b5ef30588de6975">utf8_to_system</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">utf8</a>);</div>
<div class="line"><span class="lineno">  361</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_ae95c2d5708b124dc8b5ef30588de6975"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#ae95c2d5708b124dc8b5ef30588de6975">utility_module::convert_string::utf8_to_system</a></div><div class="ttdeci">static auto utf8_to_system(const std::string &amp;value) -&gt; std::tuple&lt; std::optional&lt; std::string &gt;, std::optional&lt; std::string &gt; &gt;</div><div class="ttdoc">Converts a UTF-8 encoded string to the system encoding.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00304">convert_string.cpp:304</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a253963501540b93269546be1be251f6e" name="a253963501540b93269546be1be251f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253963501540b93269546be1be251f6e">&#9670;&#160;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::optional&lt;std::string&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <code>std::wstring</code> to a <code>std::string</code> using the system encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The wide-string input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of:<ul>
<li><code>std::optional&lt;std::string&gt;</code>: The converted narrow string on success, or <code>std::nullopt</code> on failure.</li>
<li><code>std::optional&lt;std::string&gt;</code>: The error message if conversion fails, otherwise <code>std::nullopt</code>.</li>
</ul>
</dd></dl>
<p>On Windows, this typically uses the current code page. On Unix-like systems, it may use <code>iconv</code> or locale-based conversion functions. </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00095">95</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   97</span>    {</div>
<div class="line"><span class="lineno">   98</span>        <span class="keyword">auto</span> [result, error]</div>
<div class="line"><span class="lineno">   99</span>            = convert&lt;std::wstring, std::string&gt;(value, <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a445b122955236c6ca960ac541810a3d2">get_wchar_encoding</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>),</div>
<div class="line"><span class="lineno">  100</span>                                                 <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a316651c671cec003dc927423e12d2466">get_encoding_name</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">encoding_types::utf8</a>));</div>
<div class="line"><span class="lineno">  101</span> </div>
<div class="line"><span class="lineno">  102</span>        <span class="keywordflow">if</span> (result.has_value())</div>
<div class="line"><span class="lineno">  103</span>        {</div>
<div class="line"><span class="lineno">  104</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#ae95c2d5708b124dc8b5ef30588de6975">utf8_to_system</a>(result.value());</div>
<div class="line"><span class="lineno">  105</span>        }</div>
<div class="line"><span class="lineno">  106</span> </div>
<div class="line"><span class="lineno">  107</span>        <span class="keywordflow">return</span> { std::nullopt, error };</div>
<div class="line"><span class="lineno">  108</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_a445b122955236c6ca960ac541810a3d2"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#a445b122955236c6ca960ac541810a3d2">utility_module::convert_string::get_wchar_encoding</a></div><div class="ttdeci">static auto get_wchar_encoding(endian_types endian=endian_types::little) -&gt; std::string</div><div class="ttdoc">Derives the wchar_t encoding name based on its size and endianness.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d86/convert__string_8cpp_source.html#l00181">convert_string.cpp:181</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/d53/classutility__module_1_1convert__string_a253963501540b93269546be1be251f6e_icgraph.png" border="0" usemap="#ad1/d53/classutility__module_1_1convert__string_a253963501540b93269546be1be251f6e_icgraph" alt=""/></div>
<map name="ad1/d53/classutility__module_1_1convert__string_a253963501540b93269546be1be251f6e_icgraph" id="ad1/d53/classutility__module_1_1convert__string_a253963501540b93269546be1be251f6e_icgraph">
<area shape="rect" title="Converts a std::wstring to a std::string using the system encoding." alt="" coords="240,69,413,109"/>
<area shape="rect" href="../../df/df4/classlog__module_1_1log__job.html#adcbe6490ed0744089ac7e9cb891488bc" title="Converts the stored message data (in various encodings) to std::string." alt="" coords="22,5,175,45"/>
<area shape="poly" title=" " alt="" coords="241,68,170,48,171,43,243,63"/>
<area shape="rect" href="../../de/d30/classutility__module_1_1argument__manager.html#acc2ee37fee7956fa5b52a75e2e6f406e" title="Parse command&#45;line arguments from a single (possibly wide) string." alt="" coords="5,69,192,109"/>
<area shape="poly" title=" " alt="" coords="226,92,192,92,192,87,226,87"/>
<area shape="rect" href="../../de/d30/classutility__module_1_1argument__manager.html#ad6a0850fafe8d723663ffb5c8ccbdf75" title="Parse command&#45;line arguments using the traditional argc and argv." alt="" coords="5,133,192,173"/>
<area shape="poly" title=" " alt="" coords="243,116,171,136,170,131,241,110"/>
</map>
</div>

</div>
</div>
<a id="a776bbd0131c66d25b5704348286bcbfd" name="a776bbd0131c66d25b5704348286bcbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776bbd0131c66d25b5704348286bcbfd">&#9670;&#160;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::to_string </td>
          <td>(</td>
          <td class="paramtype">std::wstring_view&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::optional&lt;std::string&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <code>std::wstring_view</code> to a <code>std::string</code> using the system encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The wide-string view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same tuple semantics as <code><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a253963501540b93269546be1be251f6e" title="Converts a std::wstring to a std::string using the system encoding.">to_string(const std::wstring&amp;)</a></code>.</dd></dl>
<p>This is a convenience overload for handling string views without copying the entire wide string first. </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00110">110</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  112</span>    {</div>
<div class="line"><span class="lineno">  113</span>        <span class="keyword">auto</span> [result, error] = convert&lt;std::wstring_view, std::string&gt;(</div>
<div class="line"><span class="lineno">  114</span>            value, <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a445b122955236c6ca960ac541810a3d2">get_wchar_encoding</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>),</div>
<div class="line"><span class="lineno">  115</span>            <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a316651c671cec003dc927423e12d2466">get_encoding_name</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">encoding_types::utf8</a>));</div>
<div class="line"><span class="lineno">  116</span> </div>
<div class="line"><span class="lineno">  117</span>        <span class="keywordflow">if</span> (result.has_value())</div>
<div class="line"><span class="lineno">  118</span>        {</div>
<div class="line"><span class="lineno">  119</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#ae95c2d5708b124dc8b5ef30588de6975">utf8_to_system</a>(result.value());</div>
<div class="line"><span class="lineno">  120</span>        }</div>
<div class="line"><span class="lineno">  121</span> </div>
<div class="line"><span class="lineno">  122</span>        <span class="keywordflow">return</span> { std::nullopt, error };</div>
<div class="line"><span class="lineno">  123</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b61bbabdc9b7a5118130f5330a928d4" name="a8b61bbabdc9b7a5118130f5330a928d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b61bbabdc9b7a5118130f5330a928d4">&#9670;&#160;</a></span>to_wstring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::optional&lt;std::wstring&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <code>std::string</code> (system-encoded) to a <code>std::wstring</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The narrow string in system encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing:<ul>
<li><code>std::optional&lt;std::wstring&gt;</code>: The converted wide string on success.</li>
<li><code>std::optional&lt;std::string&gt;</code>: An error message if conversion fails. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00125">125</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  127</span>    {</div>
<div class="line"><span class="lineno">  128</span>        <span class="keyword">auto</span> [result, err] = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#ad30f587d85f8caf0bdcfddf109d60ce0">system_to_utf8</a>(value);</div>
<div class="line"><span class="lineno">  129</span>        <span class="keywordflow">if</span> (!result.has_value())</div>
<div class="line"><span class="lineno">  130</span>        {</div>
<div class="line"><span class="lineno">  131</span>            <span class="keywordflow">return</span> { std::nullopt, err };</div>
<div class="line"><span class="lineno">  132</span>        }</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span>        std::string clean_value = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#adfae97e9adf04f637025406457671f57">remove_utf8_bom</a>(result.value());</div>
<div class="line"><span class="lineno">  135</span>        <a class="code hl_enumeration" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a> endian = <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>;</div>
<div class="line"><span class="lineno">  136</span>        <span class="keywordflow">return</span> convert&lt;std::string, std::wstring&gt;(</div>
<div class="line"><span class="lineno">  137</span>            clean_value, <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a316651c671cec003dc927423e12d2466">get_encoding_name</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">encoding_types::utf8</a>), <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a445b122955236c6ca960ac541810a3d2">get_wchar_encoding</a>(endian));</div>
<div class="line"><span class="lineno">  138</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1convert__string_html_afbde2f9b7be55d89662baedd43ba63cf"><div class="ttname"><a href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">utility_module::convert_string::endian_types</a></div><div class="ttdeci">endian_types</div><div class="ttdoc">Possible endianness values for UTF-16 or UTF-32 data.</div><div class="ttdef"><b>Definition</b> <a href="../../d1/d46/convert__string_8h_source.html#l00239">convert_string.h:240</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/d53/classutility__module_1_1convert__string_a8b61bbabdc9b7a5118130f5330a928d4_icgraph.png" border="0" usemap="#ad1/d53/classutility__module_1_1convert__string_a8b61bbabdc9b7a5118130f5330a928d4_icgraph" alt=""/></div>
<map name="ad1/d53/classutility__module_1_1convert__string_a8b61bbabdc9b7a5118130f5330a928d4_icgraph" id="ad1/d53/classutility__module_1_1convert__string_a8b61bbabdc9b7a5118130f5330a928d4_icgraph">
<area shape="rect" title="Converts a std::string (system&#45;encoded) to a std::wstring." alt="" coords="224,57,397,97"/>
<area shape="rect" href="../../d2/d09/structfmt_1_1formatter_3_01log__module_1_1log__types_00_01wchar__t_01_4.html#af079743fa5f11fbad85b265c6d371e1f" title="Formats a log_module::log_types enumerator as a wide string." alt="" coords="14,5,167,60"/>
<area shape="poly" title=" " alt="" coords="210,59,167,51,168,45,211,54"/>
<area shape="rect" href="../../dd/de7/structfmt_1_1formatter_3_01typed__thread__pool__module_1_1job__types_00_01wchar__t_01_4.html#ac6ed7b3b17851d44c12b5e4a5468efe7" title="Formats a job_types value as a wide string using {fmt}." alt="" coords="5,85,176,154"/>
<area shape="poly" title=" " alt="" coords="211,99,177,105,176,100,210,94"/>
</map>
</div>

</div>
</div>
<a id="a29faff84bcbfaff3f9216b89f9b38619" name="a29faff84bcbfaff3f9216b89f9b38619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29faff84bcbfaff3f9216b89f9b38619">&#9670;&#160;</a></span>to_wstring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::to_wstring </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::optional&lt;std::wstring&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <code>std::string_view</code> (system-encoded) to a <code>std::wstring</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The narrow string view in system encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same tuple semantics as <code><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#a8b61bbabdc9b7a5118130f5330a928d4" title="Converts a std::string (system-encoded) to a std::wstring.">to_wstring(const std::string&amp;)</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00140">140</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  142</span>    {</div>
<div class="line"><span class="lineno">  143</span>        <span class="keyword">auto</span> [result, err] = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#ad30f587d85f8caf0bdcfddf109d60ce0">system_to_utf8</a>(std::string(value));</div>
<div class="line"><span class="lineno">  144</span>        <span class="keywordflow">if</span> (!result.has_value())</div>
<div class="line"><span class="lineno">  145</span>        {</div>
<div class="line"><span class="lineno">  146</span>            <span class="keywordflow">return</span> { std::nullopt, err };</div>
<div class="line"><span class="lineno">  147</span>        }</div>
<div class="line"><span class="lineno">  148</span> </div>
<div class="line"><span class="lineno">  149</span>        std::string clean_value = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#adfae97e9adf04f637025406457671f57">remove_utf8_bom</a>(result.value());</div>
<div class="line"><span class="lineno">  150</span>        <a class="code hl_enumeration" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cf">endian_types</a> endian = <a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#afbde2f9b7be55d89662baedd43ba63cfaaae6635e044ac56046b2893a529b5114">endian_types::little</a>;</div>
<div class="line"><span class="lineno">  151</span>        <span class="keywordflow">return</span> convert&lt;std::string, std::wstring&gt;(</div>
<div class="line"><span class="lineno">  152</span>            clean_value, <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a316651c671cec003dc927423e12d2466">get_encoding_name</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">encoding_types::utf8</a>), <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a445b122955236c6ca960ac541810a3d2">get_wchar_encoding</a>(endian));</div>
<div class="line"><span class="lineno">  153</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae95c2d5708b124dc8b5ef30588de6975" name="ae95c2d5708b124dc8b5ef30588de6975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95c2d5708b124dc8b5ef30588de6975">&#9670;&#160;</a></span>utf8_to_system()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto utility_module::convert_string::utf8_to_system </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::tuple&lt;std::optional&lt;std::string&gt;, std::optional&lt;std::string&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a UTF-8 encoded string to the system encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The UTF-8 encoded input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same tuple semantics as <code><a class="el" href="../../d1/d53/classutility__module_1_1convert__string.html#ad30f587d85f8caf0bdcfddf109d60ce0" title="Converts a system-encoded string to UTF-8.">system_to_utf8()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d86/convert__string_8cpp_source.html#l00304">304</a> of file <a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  306</span>    {</div>
<div class="line"><span class="lineno">  307</span>        <span class="keywordtype">int</span> code_page = <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a72c39f9c977f20e433d4f1ddc13a3eb5">get_system_code_page</a>();</div>
<div class="line"><span class="lineno">  308</span>        <span class="keywordflow">if</span> (code_page == 65001)</div>
<div class="line"><span class="lineno">  309</span>        {</div>
<div class="line"><span class="lineno">  310</span>            <span class="keywordflow">return</span> { value, std::nullopt };</div>
<div class="line"><span class="lineno">  311</span>        }</div>
<div class="line"><span class="lineno">  312</span>        <span class="keywordflow">return</span> convert&lt;std::string, std::string&gt;(value, <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a316651c671cec003dc927423e12d2466">get_encoding_name</a>(<a class="code hl_enumvalue" href="../../d1/d53/classutility__module_1_1convert__string.html#a6ea78e52dff286b9309465a9b0f993a4a30df7f629fcf6b940bcaef5faf2490bb">encoding_types::utf8</a>),</div>
<div class="line"><span class="lineno">  313</span>                                                 <a class="code hl_function" href="../../d1/d53/classutility__module_1_1convert__string.html#a8d073801a85c823fefc5f2c00e40a2f5">get_code_page_name</a>(code_page));</div>
<div class="line"><span class="lineno">  314</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sources/utilities/<a class="el" href="../../d1/d46/convert__string_8h_source.html">convert_string.h</a></li>
<li>sources/utilities/<a class="el" href="../../d9/d86/convert__string_8cpp_source.html">convert_string.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 8 2025 06:25:36 for Thread System by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
