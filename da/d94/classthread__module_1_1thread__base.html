<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thread System: thread_module::thread_base Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Thread System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../de/d48/namespacethread__module.html">thread_module</a></li><li class="navelem"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="../../d9/d78/classthread__module_1_1thread__base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">thread_module::thread_base Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A foundational class for implementing custom worker threads.  
 <a href="../../da/d94/classthread__module_1_1thread__base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for thread_module::thread_base:</div>
<div class="dyncontent">
<div class="center"><img src="../../df/da4/classthread__module_1_1thread__base__inherit__graph.png" border="0" usemap="#athread__module_1_1thread__base_inherit__map" alt="Inheritance graph"/></div>
<map name="athread__module_1_1thread__base_inherit__map" id="athread__module_1_1thread__base_inherit__map">
<area shape="rect" title="A foundational class for implementing custom worker threads." alt="" coords="221,5,421,531"/>
<area shape="rect" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html" title=" " alt="" coords="5,581,204,876"/>
<area shape="poly" title=" " alt="" coords="217,495,176,582,171,580,212,493"/>
<area shape="rect" href="../../d7/d1b/classthread__pool__module_1_1thread__worker.html" title="A specialized worker thread that processes jobs from a job_queue." alt="" coords="229,579,413,879"/>
<area shape="poly" title=" " alt="" coords="323,545,323,578,318,578,318,545"/>
<area shape="rect" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html" title="A template&#45;based worker thread class that processes jobs from a priority job queue." alt="" coords="437,581,636,876"/>
<area shape="poly" title=" " alt="" coords="429,493,470,580,465,582,424,495"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for thread_module::thread_base:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/d30/classthread__module_1_1thread__base__coll__graph.png" border="0" usemap="#athread__module_1_1thread__base_coll__map" alt="Collaboration graph"/></div>
<map name="athread__module_1_1thread__base_coll__map" id="athread__module_1_1thread__base_coll__map">
<area shape="rect" title="A foundational class for implementing custom worker threads." alt="" coords="271,305,471,711"/>
<area shape="rect" title=" " alt="" coords="5,155,89,221"/>
<area shape="poly" title=" " alt="" coords="56,220,65,250,80,280,119,327,164,370,212,408,259,440,256,445,209,412,161,374,115,331,76,283,60,252,50,222"/>
<area shape="rect" title=" " alt="" coords="127,148,274,228"/>
<area shape="poly" title=" " alt="" coords="224,227,266,305,261,308,219,230"/>
<area shape="rect" title=" " alt="" coords="159,13,243,78"/>
<area shape="poly" title=" " alt="" coords="203,78,203,132,198,132,198,78"/>
<area shape="rect" title=" " alt="" coords="299,155,444,221"/>
<area shape="poly" title=" " alt="" coords="374,221,374,289,369,289,369,221"/>
<area shape="rect" title=" " alt="" coords="473,155,552,221"/>
<area shape="poly" title=" " alt="" coords="509,222,493,282,480,312,475,310,487,280,504,220"/>
<area shape="rect" title=" " alt="" coords="447,5,578,85"/>
<area shape="poly" title=" " alt="" coords="515,100,515,155,510,155,510,100"/>
<area shape="rect" title=" " alt="" coords="577,148,721,228"/>
<area shape="poly" title=" " alt="" coords="631,230,597,283,543,348,485,407,481,404,539,344,593,280,627,227"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0df16877f4bdab741dc5416b5a9b7fc3" id="r_a0df16877f4bdab741dc5416b5a9b7fc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a0df16877f4bdab741dc5416b5a9b7fc3">thread_base</a> (const <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp;)=delete</td></tr>
<tr class="separator:a0df16877f4bdab741dc5416b5a9b7fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867dea38e21fca0799be5bfe9c017835" id="r_a867dea38e21fca0799be5bfe9c017835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a867dea38e21fca0799be5bfe9c017835">operator=</a> (const <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp;)=delete</td></tr>
<tr class="separator:a867dea38e21fca0799be5bfe9c017835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c32ef164f713404befc8abd26ac049" id="r_a06c32ef164f713404befc8abd26ac049"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a06c32ef164f713404befc8abd26ac049">thread_base</a> (<a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a06c32ef164f713404befc8abd26ac049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26ff3e19c859033c44aadd4a279e965" id="r_ab26ff3e19c859033c44aadd4a279e965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#ab26ff3e19c859033c44aadd4a279e965">operator=</a> (<a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab26ff3e19c859033c44aadd4a279e965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0143ce267d96ab7bec174cd29a51098" id="r_ad0143ce267d96ab7bec174cd29a51098"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#ad0143ce267d96ab7bec174cd29a51098">thread_base</a> (const std::string &amp;thread_title=&quot;thread_base&quot;)</td></tr>
<tr class="memdesc:ad0143ce267d96ab7bec174cd29a51098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> object.  <br /></td></tr>
<tr class="separator:ad0143ce267d96ab7bec174cd29a51098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f96f73af7e93a9ed8595b5921f0d08" id="r_a32f96f73af7e93a9ed8595b5921f0d08"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a32f96f73af7e93a9ed8595b5921f0d08">~thread_base</a> (void)</td></tr>
<tr class="memdesc:a32f96f73af7e93a9ed8595b5921f0d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. Ensures proper cleanup of derived classes.  <br /></td></tr>
<tr class="separator:a32f96f73af7e93a9ed8595b5921f0d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3910ded89424d7f2c698bf268dad6648" id="r_a3910ded89424d7f2c698bf268dad6648"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a3910ded89424d7f2c698bf268dad6648">set_wake_interval</a> (const std::optional&lt; std::chrono::milliseconds &gt; &amp;wake_interval) -&gt; void</td></tr>
<tr class="memdesc:a3910ded89424d7f2c698bf268dad6648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interval at which the worker thread should wake up (if any).  <br /></td></tr>
<tr class="separator:a3910ded89424d7f2c698bf268dad6648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6128e53522cba44bc4fa9a1cd4635ad2" id="r_a6128e53522cba44bc4fa9a1cd4635ad2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a6128e53522cba44bc4fa9a1cd4635ad2">get_wake_interval</a> () const -&gt; std::optional&lt; std::chrono::milliseconds &gt;</td></tr>
<tr class="memdesc:a6128e53522cba44bc4fa9a1cd4635ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current wake interval setting.  <br /></td></tr>
<tr class="separator:a6128e53522cba44bc4fa9a1cd4635ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae48654e457dcf12cf7909a7e784fd89" id="r_aae48654e457dcf12cf7909a7e784fd89"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#aae48654e457dcf12cf7909a7e784fd89">start</a> (void) -&gt; <a class="el" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:aae48654e457dcf12cf7909a7e784fd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the worker thread.  <br /></td></tr>
<tr class="separator:aae48654e457dcf12cf7909a7e784fd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d46b6122580eba745e1e1d56fa1571" id="r_ac6d46b6122580eba745e1e1d56fa1571"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571">stop</a> (void) -&gt; <a class="el" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:ac6d46b6122580eba745e1e1d56fa1571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the worker thread to stop and waits for it to finish.  <br /></td></tr>
<tr class="separator:ac6d46b6122580eba745e1e1d56fa1571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef149a400f61bf4d9424bcebdc573e0" id="r_adef149a400f61bf4d9424bcebdc573e0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#adef149a400f61bf4d9424bcebdc573e0">get_thread_title</a> () const -&gt; std::string</td></tr>
<tr class="memdesc:adef149a400f61bf4d9424bcebdc573e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the worker thread's title.  <br /></td></tr>
<tr class="separator:adef149a400f61bf4d9424bcebdc573e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0650e1cf3e66769eb1a762598496b12a" id="r_a0650e1cf3e66769eb1a762598496b12a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a0650e1cf3e66769eb1a762598496b12a">is_running</a> () const -&gt; bool</td></tr>
<tr class="memdesc:a0650e1cf3e66769eb1a762598496b12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the worker thread is currently running.  <br /></td></tr>
<tr class="separator:a0650e1cf3e66769eb1a762598496b12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ab300ad2b8a1e7f46a6f669cbfe31e" id="r_a08ab300ad2b8a1e7f46a6f669cbfe31e"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a08ab300ad2b8a1e7f46a6f669cbfe31e">to_string</a> (void) const -&gt; std::string</td></tr>
<tr class="memdesc:a08ab300ad2b8a1e7f46a6f669cbfe31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of this <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> object.  <br /></td></tr>
<tr class="separator:a08ab300ad2b8a1e7f46a6f669cbfe31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aed49d6d3bcda2aa7a31b233269bc7f0f" id="r_aed49d6d3bcda2aa7a31b233269bc7f0f"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">should_continue_work</a> (void) const -&gt; bool</td></tr>
<tr class="memdesc:aed49d6d3bcda2aa7a31b233269bc7f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the thread should continue doing work.  <br /></td></tr>
<tr class="separator:aed49d6d3bcda2aa7a31b233269bc7f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06050d3b8a3accc8d202123ab3b76229" id="r_a06050d3b8a3accc8d202123ab3b76229"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a06050d3b8a3accc8d202123ab3b76229">before_start</a> (void) -&gt; <a class="el" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:a06050d3b8a3accc8d202123ab3b76229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just before the worker thread starts running.  <br /></td></tr>
<tr class="separator:a06050d3b8a3accc8d202123ab3b76229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb2e53943516cf65354f9cd5930b2d5" id="r_afeb2e53943516cf65354f9cd5930b2d5"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5">do_work</a> (void) -&gt; <a class="el" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:afeb2e53943516cf65354f9cd5930b2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main work routine for the worker thread.  <br /></td></tr>
<tr class="separator:afeb2e53943516cf65354f9cd5930b2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5b2eb7b63e97711e7bd58da331fc15" id="r_a8a5b2eb7b63e97711e7bd58da331fc15"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a8a5b2eb7b63e97711e7bd58da331fc15">after_stop</a> (void) -&gt; <a class="el" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:a8a5b2eb7b63e97711e7bd58da331fc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called immediately after the worker thread has stopped.  <br /></td></tr>
<tr class="separator:a8a5b2eb7b63e97711e7bd58da331fc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a47dad4325d074bf852e643aaf2e8fe95" id="r_a47dad4325d074bf852e643aaf2e8fe95"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::chrono::milliseconds &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a47dad4325d074bf852e643aaf2e8fe95">wake_interval_</a></td></tr>
<tr class="memdesc:a47dad4325d074bf852e643aaf2e8fe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval at which the thread is optionally awakened.  <br /></td></tr>
<tr class="separator:a47dad4325d074bf852e643aaf2e8fe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a47f05db653b3f0c75635d939a4d03ce5" id="r_a47f05db653b3f0c75635d939a4d03ce5"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a47f05db653b3f0c75635d939a4d03ce5">wake_interval_mutex_</a></td></tr>
<tr class="memdesc:a47f05db653b3f0c75635d939a4d03ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex for synchronizing access to the wake_interval_ member.  <br /></td></tr>
<tr class="separator:a47f05db653b3f0c75635d939a4d03ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e452ea7136f242b1e1b8e84758cd5c" id="r_a68e452ea7136f242b1e1b8e84758cd5c"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a68e452ea7136f242b1e1b8e84758cd5c">cv_mutex_</a></td></tr>
<tr class="memdesc:a68e452ea7136f242b1e1b8e84758cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex for synchronizing access to internal state and condition variables.  <br /></td></tr>
<tr class="separator:a68e452ea7136f242b1e1b8e84758cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1b2dce42e59a25d78761baf4dcf230" id="r_adc1b2dce42e59a25d78761baf4dcf230"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#adc1b2dce42e59a25d78761baf4dcf230">worker_condition_</a></td></tr>
<tr class="memdesc:adc1b2dce42e59a25d78761baf4dcf230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable used to block or wake the worker thread.  <br /></td></tr>
<tr class="separator:adc1b2dce42e59a25d78761baf4dcf230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ec9019ff9e44cbe30bafaef8febe45" id="r_a31ec9019ff9e44cbe30bafaef8febe45"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a></td></tr>
<tr class="memdesc:a31ec9019ff9e44cbe30bafaef8febe45"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::thread</code> for managing the worker thread's lifecycle (legacy mode).  <br /></td></tr>
<tr class="separator:a31ec9019ff9e44cbe30bafaef8febe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2010dcfce6de6920651eccffebdfde21" id="r_a2010dcfce6de6920651eccffebdfde21"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a2010dcfce6de6920651eccffebdfde21">stop_requested_</a></td></tr>
<tr class="memdesc:a2010dcfce6de6920651eccffebdfde21"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic flag to indicate that the thread should stop.  <br /></td></tr>
<tr class="separator:a2010dcfce6de6920651eccffebdfde21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e3d20e8ca3c6da11c85f9f191abda0" id="r_a87e3d20e8ca3c6da11c85f9f191abda0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a87e3d20e8ca3c6da11c85f9f191abda0">thread_title_</a></td></tr>
<tr class="memdesc:a87e3d20e8ca3c6da11c85f9f191abda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string title for identifying or naming the worker thread.  <br /></td></tr>
<tr class="separator:a87e3d20e8ca3c6da11c85f9f191abda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c110270a743ffb7405d85738bc34fa5" id="r_a7c110270a743ffb7405d85738bc34fa5"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fd">thread_conditions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a7c110270a743ffb7405d85738bc34fa5">thread_condition_</a></td></tr>
<tr class="memdesc:a7c110270a743ffb7405d85738bc34fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current condition/state of the thread (e.g., running, stopped).  <br /></td></tr>
<tr class="separator:a7c110270a743ffb7405d85738bc34fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A foundational class for implementing custom worker threads. </p>
<p>The <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> class provides a framework for managing a single worker thread, offering lifecycle methods (start, stop), optional wake intervals, and hooks (<code>before_start</code>, <code>do_work</code>, <code>after_stop</code>) for derived classes to customize behavior.</p>
<p>This class abstracts platform-specific thread management details and provides a unified interface for both C++20 <code>std::jthread</code> and traditional <code>std::thread</code>, selected at compile time via the <code>USE_STD_JTHREAD</code> macro.</p>
<h3><a class="anchor" id="autotoc_md0"></a>
Key Features</h3>
<ul>
<li>Standardized thread lifecycle management (start/stop)</li>
<li>Thread condition monitoring</li>
<li>Customizable worker behavior through virtual method overrides</li>
<li>Optional periodic wake intervals for recurring tasks</li>
<li>Built-in cancellation support (via <code>std::jthread</code> or custom mechanism)</li>
<li>Thread-safe signaling and state management</li>
</ul>
<h3><a class="anchor" id="autotoc_md1"></a>
Thread Safety</h3>
<p>All public methods in <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> are thread-safe. The class uses internal synchronization mechanisms to protect its state.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Typical Usage</h3>
<ol type="1">
<li>Inherit from <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> and override <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5" title="The main work routine for the worker thread.">do_work()</a></code>, <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a06050d3b8a3accc8d202123ab3b76229" title="Called just before the worker thread starts running.">before_start()</a></code>, and/or <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a8a5b2eb7b63e97711e7bd58da331fc15" title="Called immediately after the worker thread has stopped.">after_stop()</a></code> as needed.</li>
<li>Instantiate your derived class, set a wake interval if desired, then call <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#aae48654e457dcf12cf7909a7e784fd89" title="Starts the worker thread.">start()</a></code> to launch the thread.</li>
<li>When shutting down or no longer needing the thread's work, call <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571" title="Requests the worker thread to stop and waits for it to finish.">stop()</a></code>.</li>
<li>The thread can periodically check <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f" title="Determines whether the thread should continue doing work.">should_continue_work()</a></code> or internal conditions to determine if it should continue running.</li>
</ol>
<h3><a class="anchor" id="autotoc_md3"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_worker : <span class="keyword">public</span> <a class="code hl_class" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    my_worker() : <a class="code hl_class" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a>(<span class="stringliteral">&quot;my_worker&quot;</span>) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> before_start()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Initialize resources</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    result_void do_work()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Perform work</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    result_void after_stop()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Clean up resources</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../d6/d86/adaptive__queue__sample_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keyword">auto</span> worker = std::make_unique&lt;my_worker&gt;();</div>
<div class="line">    worker-&gt;set_wake_interval(std::chrono::milliseconds(100)); <span class="comment">// Wake every 100ms</span></div>
<div class="line">    <span class="keyword">auto</span> result = worker-&gt;start();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Do other work...</span></div>
<div class="line">    </div>
<div class="line">    worker-&gt;stop();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aadaptive__queue__sample_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="../../d6/d86/adaptive__queue__sample_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> <a href="../../d6/d86/adaptive__queue__sample_8cpp_source.html#l00443">adaptive_queue_sample.cpp:443</a></div></div>
<div class="ttc" id="aclassthread__module_1_1result__void_html"><div class="ttname"><a href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a></div><div class="ttdoc">Wrapper for void result.</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d11/error__handling_8h_source.html#l00194">error_handling.h:194</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html">thread_module::thread_base</a></div><div class="ttdoc">A foundational class for implementing custom worker threads.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00150">thread_base.h:151</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/d42/classthread__module_1_1job.html" title="Represents a unit of work (task) to be executed, typically by a job queue.">thread_module::job</a> For the work unit class processed by workers </dd>
<dd>
<a class="el" href="../../df/d6d/classthread__module_1_1job__queue.html" title="A thread-safe job queue for managing and dispatching work items.">thread_module::job_queue</a> For the thread-safe queue used with workers </dd>
<dd>
<a class="el" href="../../d7/d1b/classthread__pool__module_1_1thread__worker.html" title="A specialized worker thread that processes jobs from a job_queue.">thread_pool_module::thread_worker</a> For a specialized worker implementation </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00150">150</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0df16877f4bdab741dc5416b5a9b7fc3" name="a0df16877f4bdab741dc5416b5a9b7fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df16877f4bdab741dc5416b5a9b7fc3">&#9670;&#160;</a></span>thread_base() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_module::thread_base::thread_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06c32ef164f713404befc8abd26ac049" name="a06c32ef164f713404befc8abd26ac049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c32ef164f713404befc8abd26ac049">&#9670;&#160;</a></span>thread_base() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_module::thread_base::thread_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0143ce267d96ab7bec174cd29a51098" name="ad0143ce267d96ab7bec174cd29a51098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0143ce267d96ab7bec174cd29a51098">&#9670;&#160;</a></span>thread_base() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">thread_module::thread_base::thread_base </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>thread_title</em> = <code>&quot;thread_base&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> object. </p>
<p>Constructs a new <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a> instance with the specified title.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_title</td><td>A human-readable title for this worker thread (default: "thread_base").</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>thread_title</code> can be useful for logging, debugging, or thread naming (where the platform supports it).</p>
<p>Implementation details:</p><ul>
<li>Initializes the worker_thread_ pointer to nullptr (thread not started)</li>
<li>Sets up thread control mechanisms based on configuration:<ul>
<li>In C++20 mode (USE_STD_JTHREAD), initializes stop_source_ to std::nullopt</li>
<li>In legacy mode, initializes stop_requested_ to false</li>
</ul>
</li>
<li>Sets wake_interval_ to std::nullopt (no periodic wake-ups by default)</li>
<li>Sets thread_title_ to the provided title</li>
<li>Sets initial thread_condition_ to Created </li>
</ul>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00057">57</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   58</span>        : <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a47dad4325d074bf852e643aaf2e8fe95">wake_interval_</a>(std::nullopt)</div>
<div class="line"><span class="lineno">   59</span>        , <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a>(<span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">   60</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">   61</span>        , stop_source_(std::nullopt)</div>
<div class="line"><span class="lineno">   62</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">   63</span>        , <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a2010dcfce6de6920651eccffebdfde21">stop_requested_</a>(<span class="keyword">false</span>)</div>
<div class="line"><span class="lineno">   64</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">   65</span>        , <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a87e3d20e8ca3c6da11c85f9f191abda0">thread_title_</a>(thread_title)</div>
<div class="line"><span class="lineno">   66</span>        , <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a7c110270a743ffb7405d85738bc34fa5">thread_condition_</a>(<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fda0eceeb45861f9585dd7a97a3e36f85c6">thread_conditions::Created</a>)</div>
<div class="line"><span class="lineno">   67</span>    {</div>
<div class="line"><span class="lineno">   68</span>    }</div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a2010dcfce6de6920651eccffebdfde21"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a2010dcfce6de6920651eccffebdfde21">thread_module::thread_base::stop_requested_</a></div><div class="ttdeci">std::atomic&lt; bool &gt; stop_requested_</div><div class="ttdoc">An atomic flag to indicate that the thread should stop.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00345">thread_base.h:345</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a31ec9019ff9e44cbe30bafaef8febe45"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">thread_module::thread_base::worker_thread_</a></div><div class="ttdeci">std::unique_ptr&lt; std::thread &gt; worker_thread_</div><div class="ttdoc">A std::thread for managing the worker thread's lifecycle (legacy mode).</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00338">thread_base.h:338</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a47dad4325d074bf852e643aaf2e8fe95"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a47dad4325d074bf852e643aaf2e8fe95">thread_module::thread_base::wake_interval_</a></div><div class="ttdeci">std::optional&lt; std::chrono::milliseconds &gt; wake_interval_</div><div class="ttdoc">Interval at which the thread is optionally awakened.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00292">thread_base.h:292</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a7c110270a743ffb7405d85738bc34fa5"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a7c110270a743ffb7405d85738bc34fa5">thread_module::thread_base::thread_condition_</a></div><div class="ttdeci">std::atomic&lt; thread_conditions &gt; thread_condition_</div><div class="ttdoc">The current condition/state of the thread (e.g., running, stopped).</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00359">thread_base.h:359</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a87e3d20e8ca3c6da11c85f9f191abda0"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a87e3d20e8ca3c6da11c85f9f191abda0">thread_module::thread_base::thread_title_</a></div><div class="ttdeci">std::string thread_title_</div><div class="ttdoc">A string title for identifying or naming the worker thread.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00351">thread_base.h:351</a></div></div>
<div class="ttc" id="anamespacethread__module_html_ac36545c2cec0c3066226f519c089c5fda0eceeb45861f9585dd7a97a3e36f85c6"><div class="ttname"><a href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fda0eceeb45861f9585dd7a97a3e36f85c6">thread_module::thread_conditions::Created</a></div><div class="ttdeci">@ Created</div><div class="ttdoc">Thread created but not started.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a32f96f73af7e93a9ed8595b5921f0d08" name="a32f96f73af7e93a9ed8595b5921f0d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f96f73af7e93a9ed8595b5921f0d08">&#9670;&#160;</a></span>~thread_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_module::thread_base::~thread_base </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. Ensures proper cleanup of derived classes. </p>
<p>Destroys the <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a> instance, stopping the thread if needed.</p>
<p>If the thread is still running when the destructor is called, <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571" title="Requests the worker thread to stop and waits for it to finish.">stop()</a></code> is typically called internally to join the thread before destruction.</p>
<p>Implementation details:</p><ul>
<li>Calls <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571" title="Requests the worker thread to stop and waits for it to finish.">stop()</a> to ensure the thread is properly terminated</li>
<li>The <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571" title="Requests the worker thread to stop and waits for it to finish.">stop()</a> method handles joining the thread and cleaning up resources</li>
<li>This ensures no thread resources are leaked when the object is destroyed</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This destructor is virtual, allowing derived classes to perform their own cleanup operations in their destructors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00081">81</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   81</span>{ <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571">stop</a>(); }</div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_ac6d46b6122580eba745e1e1d56fa1571"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571">thread_module::thread_base::stop</a></div><div class="ttdeci">auto stop(void) -&gt; result_void</div><div class="ttdoc">Requests the worker thread to stop and waits for it to finish.</div><div class="ttdef"><b>Definition</b> <a href="../../df/d10/thread__base_8cpp_source.html#l00333">thread_base.cpp:333</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../da/d94/classthread__module_1_1thread__base_a32f96f73af7e93a9ed8595b5921f0d08_cgraph.png" border="0" usemap="#ada/d94/classthread__module_1_1thread__base_a32f96f73af7e93a9ed8595b5921f0d08_cgraph" alt=""/></div>
<map name="ada/d94/classthread__module_1_1thread__base_a32f96f73af7e93a9ed8595b5921f0d08_cgraph" id="ada/d94/classthread__module_1_1thread__base_a32f96f73af7e93a9ed8595b5921f0d08_cgraph">
<area shape="rect" title="Virtual destructor. Ensures proper cleanup of derived classes." alt="" coords="5,5,176,45"/>
<area shape="rect" href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571" title="Requests the worker thread to stop and waits for it to finish." alt="" coords="224,5,395,45"/>
<area shape="poly" title=" " alt="" coords="176,23,210,23,210,28,176,28"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8a5b2eb7b63e97711e7bd58da331fc15" name="a8a5b2eb7b63e97711e7bd58da331fc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5b2eb7b63e97711e7bd58da331fc15">&#9670;&#160;</a></span>after_stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual auto thread_module::thread_base::after_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called immediately after the worker thread has stopped. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="../../dd/da2/classthread__module_1_1result__void.html" title="Wrapper for void result.">result_void</a></code> containing an error on failure, or success value if successful.</dd></dl>
<p>Override this method in derived classes to perform any cleanup or finalization tasks once the worker thread has fully exited. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00281">281</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  281</span>{ <span class="keywordflow">return</span> {}; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a06050d3b8a3accc8d202123ab3b76229" name="a06050d3b8a3accc8d202123ab3b76229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06050d3b8a3accc8d202123ab3b76229">&#9670;&#160;</a></span>before_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual auto thread_module::thread_base::before_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just before the worker thread starts running. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="../../dd/da2/classthread__module_1_1result__void.html" title="Wrapper for void result.">result_void</a></code> containing an error on failure, or success value if successful.</dd></dl>
<p>Override this method in derived classes to perform any initialization or setup required before the worker thread begins its main loop. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00262">262</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  262</span>{ <span class="keywordflow">return</span> {}; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afeb2e53943516cf65354f9cd5930b2d5" name="afeb2e53943516cf65354f9cd5930b2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb2e53943516cf65354f9cd5930b2d5">&#9670;&#160;</a></span>do_work()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual auto thread_module::thread_base::do_work </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main work routine for the worker thread. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="../../dd/da2/classthread__module_1_1result__void.html" title="Wrapper for void result.">result_void</a></code> containing an error on failure, or success value if successful.</dd></dl>
<p>Derived classes should override this method to implement the actual work the thread needs to perform. This method is called repeatedly (in an internal loop) until the thread is signaled to stop or <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f" title="Determines whether the thread should continue doing work.">should_continue_work()</a></code> returns <code>false</code>. </p>

<p>Reimplemented in <a class="el" href="../../d7/d1b/classthread__pool__module_1_1thread__worker.html#a3de7e59a29b65f516d7e871b2b3d5877">thread_pool_module::thread_worker</a>, <a class="el" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html#abaed427230a66a01b8e40ed117ae8204">typed_thread_pool_module::typed_thread_worker_t&lt; job_type &gt;</a>, and <a class="el" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html#abaed427230a66a01b8e40ed117ae8204">typed_thread_pool_module::typed_thread_worker_t&lt; job_types &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00272">272</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  272</span>{ <span class="keywordflow">return</span> {}; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adef149a400f61bf4d9424bcebdc573e0" name="adef149a400f61bf4d9424bcebdc573e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef149a400f61bf4d9424bcebdc573e0">&#9670;&#160;</a></span>get_thread_title()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto thread_module::thread_base::get_thread_title </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; std::string </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the worker thread's title. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representing the thread's title. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00224">224</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  224</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a87e3d20e8ca3c6da11c85f9f191abda0">thread_title_</a>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6128e53522cba44bc4fa9a1cd4635ad2" name="a6128e53522cba44bc4fa9a1cd4635ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6128e53522cba44bc4fa9a1cd4635ad2">&#9670;&#160;</a></span>get_wake_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto thread_module::thread_base::get_wake_interval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; std::optional&lt;std::chrono::milliseconds&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current wake interval setting. </p>
<dl class="section return"><dt>Returns</dt><dd>The wake interval if set, or <code>std::nullopt</code> if periodic wake-ups are disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is thread-safe.</dd></dl>
<p>Implementation details:</p><ul>
<li>Uses the same mutex as <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a3910ded89424d7f2c698bf268dad6648" title="Sets the interval at which the worker thread should wake up (if any).">set_wake_interval()</a> for consistency</li>
<li>Returns a copy of the current wake_interval_ value</li>
<li>std::nullopt indicates no periodic wake-ups are configured</li>
</ul>
<p>Thread Safety:</p><ul>
<li>Safe to call from any thread concurrently with <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a3910ded89424d7f2c698bf268dad6648" title="Sets the interval at which the worker thread should wake up (if any).">set_wake_interval()</a></li>
<li>The mutex ensures consistent reads even during concurrent modifications</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Current wake interval or std::nullopt if disabled </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00118">118</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  120</span>    {</div>
<div class="line"><span class="lineno">  121</span>        <span class="comment">// Thread-safe read of wake_interval</span></div>
<div class="line"><span class="lineno">  122</span>        std::scoped_lock&lt;std::mutex&gt; lock(<a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a47f05db653b3f0c75635d939a4d03ce5">wake_interval_mutex_</a>);</div>
<div class="line"><span class="lineno">  123</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a47dad4325d074bf852e643aaf2e8fe95">wake_interval_</a>;</div>
<div class="line"><span class="lineno">  124</span>    }</div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a47f05db653b3f0c75635d939a4d03ce5"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a47f05db653b3f0c75635d939a4d03ce5">thread_module::thread_base::wake_interval_mutex_</a></div><div class="ttdeci">std::mutex wake_interval_mutex_</div><div class="ttdoc">Mutex for synchronizing access to the wake_interval_ member.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00301">thread_base.h:301</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0650e1cf3e66769eb1a762598496b12a" name="a0650e1cf3e66769eb1a762598496b12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0650e1cf3e66769eb1a762598496b12a">&#9670;&#160;</a></span>is_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto thread_module::thread_base::is_running </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the worker thread is currently running. </p>
<p>Checks if the worker thread is currently active.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the thread is running, <code>false</code> otherwise.</dd></dl>
<p>This depends on the thread's internal condition state (e.g., <code>thread_conditions::running</code>).</p>
<p>Implementation details:</p><ul>
<li>Uses the atomic thread_condition_ member instead of checking thread pointers</li>
<li>This is more reliable as it reflects the actual thread state</li>
<li>Considers both Working and Waiting states as "running"</li>
<li>Thread-safe operation due to atomic load</li>
</ul>
<p>Thread States Considered "Running":</p><ul>
<li>Working: Thread is actively executing <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5" title="The main work routine for the worker thread.">do_work()</a></li>
<li>Waiting: Thread is alive but waiting for work or timeout</li>
</ul>
<p>Thread States NOT Considered "Running":</p><ul>
<li>Created: Thread object created but not started</li>
<li>Stopping: Thread is in shutdown sequence</li>
<li>Stopped: Thread has completely finished</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if thread is actively running (Working or Waiting) </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00396">396</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  397</span>    { </div>
<div class="line"><span class="lineno">  398</span>        <span class="comment">// Use the thread_condition_ atomic flag instead of checking the pointer</span></div>
<div class="line"><span class="lineno">  399</span>        <span class="keyword">auto</span> condition = <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a7c110270a743ffb7405d85738bc34fa5">thread_condition_</a>.load();</div>
<div class="line"><span class="lineno">  400</span>        <span class="keywordflow">return</span> condition == <a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fda829eadc8e29caab50cc26bc6a451a1f1">thread_conditions::Working</a> || </div>
<div class="line"><span class="lineno">  401</span>               condition == <a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fda5706de961fb376d701be6e7762d8b09c">thread_conditions::Waiting</a>;</div>
<div class="line"><span class="lineno">  402</span>    }</div>
<div class="ttc" id="anamespacethread__module_html_ac36545c2cec0c3066226f519c089c5fda5706de961fb376d701be6e7762d8b09c"><div class="ttname"><a href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fda5706de961fb376d701be6e7762d8b09c">thread_module::thread_conditions::Waiting</a></div><div class="ttdeci">@ Waiting</div><div class="ttdoc">Thread waiting for work or tasks.</div></div>
<div class="ttc" id="anamespacethread__module_html_ac36545c2cec0c3066226f519c089c5fda829eadc8e29caab50cc26bc6a451a1f1"><div class="ttname"><a href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fda829eadc8e29caab50cc26bc6a451a1f1">thread_module::thread_conditions::Working</a></div><div class="ttdeci">@ Working</div><div class="ttdoc">Thread currently processing a task.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a867dea38e21fca0799be5bfe9c017835" name="a867dea38e21fca0799be5bfe9c017835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867dea38e21fca0799be5bfe9c017835">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp; thread_module::thread_base::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab26ff3e19c859033c44aadd4a279e965" name="ab26ff3e19c859033c44aadd4a279e965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26ff3e19c859033c44aadd4a279e965">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp; thread_module::thread_base::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html">thread_base</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3910ded89424d7f2c698bf268dad6648" name="a3910ded89424d7f2c698bf268dad6648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3910ded89424d7f2c698bf268dad6648">&#9670;&#160;</a></span>set_wake_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto thread_module::thread_base::set_wake_interval </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; std::chrono::milliseconds &gt; &amp;&#160;</td>
          <td class="paramname"><em>wake_interval</em></td><td>)</td>
          <td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interval at which the worker thread should wake up (if any). </p>
<p>Sets the wake interval for periodic thread wake-ups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wake_interval</td><td>Duration in milliseconds for periodic wake-ups, or <code>std::nullopt</code> to disable periodic wake-ups.</td></tr>
  </table>
  </dd>
</dl>
<p>If a wake interval is set, the worker thread can periodically perform some action (e.g., housekeeping tasks) even if there's no immediate external signal.</p>
<dl class="section note"><dt>Note</dt><dd>This method is thread-safe.</dd></dl>
<p>Implementation details:</p><ul>
<li>Uses a dedicated mutex (wake_interval_mutex_) to ensure thread-safe access</li>
<li>The scoped_lock ensures automatic release when the function exits</li>
<li>This interval controls how often the thread wakes up even when idle</li>
<li>Setting std::nullopt disables periodic wake-ups (thread only wakes on signals)</li>
</ul>
<p>Thread Safety:</p><ul>
<li>Safe to call from any thread while the worker thread is running</li>
<li>The wake_interval_mutex_ protects against data races with <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a6128e53522cba44bc4fa9a1cd4635ad2" title="Gets the current wake interval setting.">get_wake_interval()</a> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00096">96</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   98</span>    {</div>
<div class="line"><span class="lineno">   99</span>        <span class="comment">// Use dedicated mutex for wake_interval to prevent data races</span></div>
<div class="line"><span class="lineno">  100</span>        std::scoped_lock&lt;std::mutex&gt; lock(<a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a47f05db653b3f0c75635d939a4d03ce5">wake_interval_mutex_</a>);</div>
<div class="line"><span class="lineno">  101</span>        <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a47dad4325d074bf852e643aaf2e8fe95">wake_interval_</a> = wake_interval;</div>
<div class="line"><span class="lineno">  102</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aed49d6d3bcda2aa7a31b233269bc7f0f" name="aed49d6d3bcda2aa7a31b233269bc7f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed49d6d3bcda2aa7a31b233269bc7f0f">&#9670;&#160;</a></span>should_continue_work()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual auto thread_module::thread_base::should_continue_work </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the thread should continue doing work. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is work to do, <code>false</code> otherwise.</dd></dl>
<p>The default implementation always returns <code>false</code> (indicating no ongoing work). Override this in derived classes if you wish the thread to perform repeated tasks until some condition changes. </p>

<p>Reimplemented in <a class="el" href="../../d7/d1b/classthread__pool__module_1_1thread__worker.html#ae38261aaa674556fbff48afd2ca13ab7">thread_pool_module::thread_worker</a>, <a class="el" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html#aa903598f572540b7d6f2039396e91400">typed_thread_pool_module::typed_thread_worker_t&lt; job_type &gt;</a>, and <a class="el" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html#aa903598f572540b7d6f2039396e91400">typed_thread_pool_module::typed_thread_worker_t&lt; job_types &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00253">253</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  253</span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aae48654e457dcf12cf7909a7e784fd89" name="aae48654e457dcf12cf7909a7e784fd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae48654e457dcf12cf7909a7e784fd89">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto thread_module::thread_base::start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the worker thread. </p>
<p>Starts the worker thread and begins execution loop.</p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="../../dd/da2/classthread__module_1_1result__void.html" title="Wrapper for void result.">result_void</a></code> containing an error on failure, or success value if successful.</dd></dl>
<p>Internally, this method:</p><ol type="1">
<li>Calls <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a06050d3b8a3accc8d202123ab3b76229" title="Called just before the worker thread starts running.">before_start()</a></code> to allow derived classes to perform setup.</li>
<li>Spawns a new thread (using either <code>std::jthread</code> or <code>std::thread</code>).</li>
<li>Repeatedly calls <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5" title="The main work routine for the worker thread.">do_work()</a></code> until the thread is signaled to stop.</li>
</ol>
<p>Implementation details:</p><ul>
<li>First checks if thread is already running using different methods:<ul>
<li>C++20: stop_source_.has_value() indicates active thread</li>
<li>Legacy: worker_thread_-&gt;joinable() indicates active thread</li>
</ul>
</li>
<li>Calls <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571" title="Requests the worker thread to stop and waits for it to finish.">stop()</a> first to ensure clean state (idempotent operation)</li>
<li>Initializes stop control mechanism:<ul>
<li>C++20: Creates new std::stop_source for cooperative cancellation</li>
<li>Legacy: Resets atomic stop_requested_ flag to false</li>
</ul>
</li>
<li>Creates worker thread that executes the main work loop</li>
</ul>
<p>Main Work Loop Logic:</p><ol type="1">
<li>Calls <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a06050d3b8a3accc8d202123ab3b76229" title="Called just before the worker thread starts running.">before_start()</a> hook for derived class initialization</li>
<li>Enters main loop while not stopped and has work to do</li>
<li>Sets thread_condition_ to Waiting before sleep</li>
<li>Waits on condition variable with optional timeout (wake_interval)</li>
<li>Sets thread_condition_ to Working before calling <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5" title="The main work routine for the worker thread.">do_work()</a></li>
<li>Calls <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5" title="The main work routine for the worker thread.">do_work()</a> hook for actual work execution</li>
<li>Handles exceptions from <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5" title="The main work routine for the worker thread.">do_work()</a> gracefully</li>
<li>Calls <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a8a5b2eb7b63e97711e7bd58da331fc15" title="Called immediately after the worker thread has stopped.">after_stop()</a> hook for cleanup when exiting</li>
</ol>
<p>Error Handling:</p><ul>
<li>Returns error if thread is already running</li>
<li>Catches std::bad_alloc during thread creation</li>
<li>Logs errors from hooks using std::cerr</li>
<li>Exception-safe cleanup in catch blocks</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Empty result on success, error on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00157">157</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  158</span>    {</div>
<div class="line"><span class="lineno">  159</span>        <span class="comment">// Check if thread is already running using platform-specific method</span></div>
<div class="line"><span class="lineno">  160</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  161</span>        <span class="keywordflow">if</span> (stop_source_.has_value())</div>
<div class="line"><span class="lineno">  162</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  163</span>        <span class="keywordflow">if</span> (<a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a> &amp;&amp; <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a>-&gt;joinable())</div>
<div class="line"><span class="lineno">  164</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  165</span>        {</div>
<div class="line"><span class="lineno">  166</span>            <span class="keywordflow">return</span> result_void{<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#a5a2719d6d43f27e1e8e913fbfa5c9288acb5e100e5a9a3e7f6d1fd97512215282">error</a>{<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#a215ffba45222b5527566469d33e4447cae6fac5620122dc140bbc13a44aeac670">error_code::thread_already_running</a>, <span class="stringliteral">&quot;thread is already running&quot;</span>}};</div>
<div class="line"><span class="lineno">  167</span>        }</div>
<div class="line"><span class="lineno">  168</span> </div>
<div class="line"><span class="lineno">  169</span>        <span class="comment">// Ensure clean state by stopping any existing thread first</span></div>
<div class="line"><span class="lineno">  170</span>        <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571">stop</a>();</div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>        <span class="comment">// Initialize stop control mechanism for the new thread</span></div>
<div class="line"><span class="lineno">  173</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  174</span>        stop_source_ = std::stop_source();</div>
<div class="line"><span class="lineno">  175</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  176</span>        <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a2010dcfce6de6920651eccffebdfde21">stop_requested_</a> = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  177</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  178</span> </div>
<div class="line"><span class="lineno">  179</span>        <span class="keywordflow">try</span></div>
<div class="line"><span class="lineno">  180</span>        {</div>
<div class="line"><span class="lineno">  181</span>            <span class="comment">// Create the worker thread using platform-appropriate thread type</span></div>
<div class="line"><span class="lineno">  182</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  183</span>            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a> = std::make_unique&lt;std::jthread&gt;(</div>
<div class="line"><span class="lineno">  184</span>#<span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  185</span>            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a> = std::make_unique&lt;std::thread&gt;(</div>
<div class="line"><span class="lineno">  186</span>#endif</div>
<div class="line"><span class="lineno">  187</span>                [<span class="keyword">this</span>](<span class="keywordtype">void</span>)  <span class="comment">// Capture &#39;this&#39; to access member functions and variables</span></div>
<div class="line"><span class="lineno">  188</span>                {</div>
<div class="line"><span class="lineno">  189</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  190</span>                    <span class="comment">// Get stop token for cooperative cancellation in C++20</span></div>
<div class="line"><span class="lineno">  191</span>                    <span class="keyword">auto</span> stop_token = stop_source_.value().get_token();</div>
<div class="line"><span class="lineno">  192</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>                    <span class="comment">// Phase 1: Call derived class initialization hook</span></div>
<div class="line"><span class="lineno">  195</span>                    <span class="keyword">auto</span> work_result = <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#a06050d3b8a3accc8d202123ab3b76229">before_start</a>();</div>
<div class="line"><span class="lineno">  196</span>                    <span class="keywordflow">if</span> (work_result.has_error())</div>
<div class="line"><span class="lineno">  197</span>                    {</div>
<div class="line"><span class="lineno">  198</span>                        std::cerr &lt;&lt; <span class="stringliteral">&quot;error before start: &quot;</span> &lt;&lt; work_result.get_error().to_string()</div>
<div class="line"><span class="lineno">  199</span>                                  &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  200</span>                    }</div>
<div class="line"><span class="lineno">  201</span> </div>
<div class="line"><span class="lineno">  202</span>                    <span class="comment">// Phase 2: Main work loop - continues until stop requested and no more work</span></div>
<div class="line"><span class="lineno">  203</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  204</span>                    <span class="keywordflow">while</span> (!stop_token.stop_requested() || <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">should_continue_work</a>())</div>
<div class="line"><span class="lineno">  205</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  206</span>                    <span class="keywordflow">while</span> (!<a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a2010dcfce6de6920651eccffebdfde21">stop_requested_</a> || <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">should_continue_work</a>())</div>
<div class="line"><span class="lineno">  207</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  208</span>                    {</div>
<div class="line"><span class="lineno">  209</span>                        <span class="comment">// Update thread state to indicate it&#39;s waiting for work</span></div>
<div class="line"><span class="lineno">  210</span>                        <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a7c110270a743ffb7405d85738bc34fa5">thread_condition_</a>.store(<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fda5706de961fb376d701be6e7762d8b09c">thread_conditions::Waiting</a>);</div>
<div class="line"><span class="lineno">  211</span> </div>
<div class="line"><span class="lineno">  212</span>                        <span class="comment">// Get current wake interval with thread-safe access</span></div>
<div class="line"><span class="lineno">  213</span>                        <span class="keyword">auto</span> interval = <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#a6128e53522cba44bc4fa9a1cd4635ad2">get_wake_interval</a>();</div>
<div class="line"><span class="lineno">  214</span>                        </div>
<div class="line"><span class="lineno">  215</span>                        <span class="comment">// Use unique_lock for condition variable operations (required by std::condition_variable)</span></div>
<div class="line"><span class="lineno">  216</span>                        std::unique_lock&lt;std::mutex&gt; lock(<a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a68e452ea7136f242b1e1b8e84758cd5c">cv_mutex_</a>);</div>
<div class="line"><span class="lineno">  217</span>                        </div>
<div class="line"><span class="lineno">  218</span>                        <span class="comment">// Wait strategy depends on whether wake interval is configured</span></div>
<div class="line"><span class="lineno">  219</span>                        <span class="keywordflow">if</span> (interval.has_value())</div>
<div class="line"><span class="lineno">  220</span>                        {</div>
<div class="line"><span class="lineno">  221</span>                            <span class="comment">// Timed wait: wake up after interval OR when condition is met</span></div>
<div class="line"><span class="lineno">  222</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  223</span>                            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#adc1b2dce42e59a25d78761baf4dcf230">worker_condition_</a>.wait_for(</div>
<div class="line"><span class="lineno">  224</span>                                lock, interval.value(), [<span class="keyword">this</span>, &amp;stop_token]()</div>
<div class="line"><span class="lineno">  225</span>                                { return stop_token.stop_requested() || should_continue_work(); });</div>
<div class="line"><span class="lineno">  226</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  227</span>                            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#adc1b2dce42e59a25d78761baf4dcf230">worker_condition_</a>.wait_for(</div>
<div class="line"><span class="lineno">  228</span>                                lock, interval.value(),</div>
<div class="line"><span class="lineno">  229</span>                                [<span class="keyword">this</span>]() { return stop_requested_ || should_continue_work(); });</div>
<div class="line"><span class="lineno">  230</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  231</span>                        }</div>
<div class="line"><span class="lineno">  232</span>                        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  233</span>                        {</div>
<div class="line"><span class="lineno">  234</span>                            <span class="comment">// Indefinite wait: only wake up when condition is met</span></div>
<div class="line"><span class="lineno">  235</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  236</span>                            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#adc1b2dce42e59a25d78761baf4dcf230">worker_condition_</a>.wait(</div>
<div class="line"><span class="lineno">  237</span>                                lock, [<span class="keyword">this</span>, &amp;stop_token]()</div>
<div class="line"><span class="lineno">  238</span>                                { <span class="keywordflow">return</span> stop_token.stop_requested() || <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">should_continue_work</a>(); });</div>
<div class="line"><span class="lineno">  239</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  240</span>                            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#adc1b2dce42e59a25d78761baf4dcf230">worker_condition_</a>.wait(</div>
<div class="line"><span class="lineno">  241</span>                                lock,</div>
<div class="line"><span class="lineno">  242</span>                                [<span class="keyword">this</span>]() { <span class="keywordflow">return</span> <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a2010dcfce6de6920651eccffebdfde21">stop_requested_</a> || <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">should_continue_work</a>(); });</div>
<div class="line"><span class="lineno">  243</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  244</span>                        }</div>
<div class="line"><span class="lineno">  245</span> </div>
<div class="line"><span class="lineno">  246</span>                        <span class="comment">// Check if we should exit the loop</span></div>
<div class="line"><span class="lineno">  247</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  248</span>                        <span class="keywordflow">if</span> (stop_token.stop_requested() &amp;&amp; !<a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">should_continue_work</a>())</div>
<div class="line"><span class="lineno">  249</span>#<span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  250</span>                        <span class="keywordflow">if</span> (<a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a2010dcfce6de6920651eccffebdfde21">stop_requested_</a> &amp;&amp; !<a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">should_continue_work</a>())</div>
<div class="line"><span class="lineno">  251</span>#endif</div>
<div class="line"><span class="lineno">  252</span>                        {</div>
<div class="line"><span class="lineno">  253</span>                            <span class="comment">// Update state to indicate graceful shutdown in progress</span></div>
<div class="line"><span class="lineno">  254</span>                            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a7c110270a743ffb7405d85738bc34fa5">thread_condition_</a>.store(<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fda7b7ecb39b9e110c2a31409a1672bad23">thread_conditions::Stopping</a>);</div>
<div class="line"><span class="lineno">  255</span>                            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  256</span>                        }</div>
<div class="line"><span class="lineno">  257</span> </div>
<div class="line"><span class="lineno">  258</span>                        <span class="comment">// Execute the actual work with exception protection</span></div>
<div class="line"><span class="lineno">  259</span>                        <span class="keywordflow">try</span></div>
<div class="line"><span class="lineno">  260</span>                        {</div>
<div class="line"><span class="lineno">  261</span>                            <span class="comment">// Update state to indicate active work is being performed</span></div>
<div class="line"><span class="lineno">  262</span>                            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a7c110270a743ffb7405d85738bc34fa5">thread_condition_</a>.store(<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fda829eadc8e29caab50cc26bc6a451a1f1">thread_conditions::Working</a>);</div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span>                            <span class="comment">// Call derived class work implementation</span></div>
<div class="line"><span class="lineno">  265</span>                            work_result = <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5">do_work</a>();</div>
<div class="line"><span class="lineno">  266</span>                            <span class="keywordflow">if</span> (work_result.has_error())</div>
<div class="line"><span class="lineno">  267</span>                            {</div>
<div class="line"><span class="lineno">  268</span>                                std::cerr &lt;&lt; <span class="stringliteral">&quot;error doing work on &quot;</span> &lt;&lt; <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a87e3d20e8ca3c6da11c85f9f191abda0">thread_title_</a> &lt;&lt; <span class="stringliteral">&quot; : &quot;</span></div>
<div class="line"><span class="lineno">  269</span>                                          &lt;&lt; work_result.get_error().to_string() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  270</span>                            }</div>
<div class="line"><span class="lineno">  271</span>                        }</div>
<div class="line"><span class="lineno">  272</span>                        <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e)</div>
<div class="line"><span class="lineno">  273</span>                        {</div>
<div class="line"><span class="lineno">  274</span>                            <span class="comment">// Log any unhandled exceptions from do_work() but continue running</span></div>
<div class="line"><span class="lineno">  275</span>                            std::cerr &lt;&lt; <span class="stringliteral">&quot;exception in &quot;</span> &lt;&lt; <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a87e3d20e8ca3c6da11c85f9f191abda0">thread_title_</a> &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"><span class="lineno">  276</span>                        }</div>
<div class="line"><span class="lineno">  277</span>                    }</div>
<div class="line"><span class="lineno">  278</span> </div>
<div class="line"><span class="lineno">  279</span>                    <span class="comment">// Phase 3: Call derived class cleanup hook after main loop exits</span></div>
<div class="line"><span class="lineno">  280</span>                    work_result = <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#a8a5b2eb7b63e97711e7bd58da331fc15">after_stop</a>();</div>
<div class="line"><span class="lineno">  281</span>                    <span class="keywordflow">if</span> (work_result.has_error())</div>
<div class="line"><span class="lineno">  282</span>                    {</div>
<div class="line"><span class="lineno">  283</span>                        std::cerr &lt;&lt; <span class="stringliteral">&quot;error after stop: &quot;</span> &lt;&lt; work_result.get_error().to_string()</div>
<div class="line"><span class="lineno">  284</span>                                  &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  285</span>                    }</div>
<div class="line"><span class="lineno">  286</span>                });  <span class="comment">// End of lambda function passed to thread constructor</span></div>
<div class="line"><span class="lineno">  287</span>        }</div>
<div class="line"><span class="lineno">  288</span>        <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::bad_alloc&amp; e)</div>
<div class="line"><span class="lineno">  289</span>        {</div>
<div class="line"><span class="lineno">  290</span>            <span class="comment">// Exception-safe cleanup: reset all resources if thread creation fails</span></div>
<div class="line"><span class="lineno">  291</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  292</span>            stop_source_.reset();</div>
<div class="line"><span class="lineno">  293</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  294</span>            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a2010dcfce6de6920651eccffebdfde21">stop_requested_</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  295</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  296</span> </div>
<div class="line"><span class="lineno">  297</span>            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a>.reset();</div>
<div class="line"><span class="lineno">  298</span> </div>
<div class="line"><span class="lineno">  299</span>            <span class="keywordflow">return</span> result_void{<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#a5a2719d6d43f27e1e8e913fbfa5c9288acb5e100e5a9a3e7f6d1fd97512215282">error</a>{<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#a215ffba45222b5527566469d33e4447cacde679dc006944a4dcc197c13cf731e5">error_code::resource_allocation_failed</a>, e.what()}};</div>
<div class="line"><span class="lineno">  300</span>        }</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span>        <span class="comment">// Thread creation successful</span></div>
<div class="line"><span class="lineno">  303</span>        <span class="keywordflow">return</span> {};</div>
<div class="line"><span class="lineno">  304</span>    }</div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a06050d3b8a3accc8d202123ab3b76229"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a06050d3b8a3accc8d202123ab3b76229">thread_module::thread_base::before_start</a></div><div class="ttdeci">virtual auto before_start(void) -&gt; result_void</div><div class="ttdoc">Called just before the worker thread starts running.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00262">thread_base.h:262</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a6128e53522cba44bc4fa9a1cd4635ad2"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a6128e53522cba44bc4fa9a1cd4635ad2">thread_module::thread_base::get_wake_interval</a></div><div class="ttdeci">auto get_wake_interval() const -&gt; std::optional&lt; std::chrono::milliseconds &gt;</div><div class="ttdoc">Gets the current wake interval setting.</div><div class="ttdef"><b>Definition</b> <a href="../../df/d10/thread__base_8cpp_source.html#l00118">thread_base.cpp:118</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a68e452ea7136f242b1e1b8e84758cd5c"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a68e452ea7136f242b1e1b8e84758cd5c">thread_module::thread_base::cv_mutex_</a></div><div class="ttdeci">std::mutex cv_mutex_</div><div class="ttdoc">Mutex for synchronizing access to internal state and condition variables.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00309">thread_base.h:309</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a8a5b2eb7b63e97711e7bd58da331fc15"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a8a5b2eb7b63e97711e7bd58da331fc15">thread_module::thread_base::after_stop</a></div><div class="ttdeci">virtual auto after_stop(void) -&gt; result_void</div><div class="ttdoc">Called immediately after the worker thread has stopped.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00281">thread_base.h:281</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_adc1b2dce42e59a25d78761baf4dcf230"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#adc1b2dce42e59a25d78761baf4dcf230">thread_module::thread_base::worker_condition_</a></div><div class="ttdeci">std::condition_variable worker_condition_</div><div class="ttdoc">Condition variable used to block or wake the worker thread.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00317">thread_base.h:317</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_aed49d6d3bcda2aa7a31b233269bc7f0f"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">thread_module::thread_base::should_continue_work</a></div><div class="ttdeci">virtual auto should_continue_work(void) const -&gt; bool</div><div class="ttdoc">Determines whether the thread should continue doing work.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00253">thread_base.h:253</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_afeb2e53943516cf65354f9cd5930b2d5"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5">thread_module::thread_base::do_work</a></div><div class="ttdeci">virtual auto do_work(void) -&gt; result_void</div><div class="ttdoc">The main work routine for the worker thread.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00272">thread_base.h:272</a></div></div>
<div class="ttc" id="anamespacethread__module_html_a215ffba45222b5527566469d33e4447cacde679dc006944a4dcc197c13cf731e5"><div class="ttname"><a href="../../de/d48/namespacethread__module.html#a215ffba45222b5527566469d33e4447cacde679dc006944a4dcc197c13cf731e5">thread_module::error_code::resource_allocation_failed</a></div><div class="ttdeci">@ resource_allocation_failed</div></div>
<div class="ttc" id="anamespacethread__module_html_a215ffba45222b5527566469d33e4447cae6fac5620122dc140bbc13a44aeac670"><div class="ttname"><a href="../../de/d48/namespacethread__module.html#a215ffba45222b5527566469d33e4447cae6fac5620122dc140bbc13a44aeac670">thread_module::error_code::thread_already_running</a></div><div class="ttdeci">@ thread_already_running</div></div>
<div class="ttc" id="anamespacethread__module_html_a5a2719d6d43f27e1e8e913fbfa5c9288acb5e100e5a9a3e7f6d1fd97512215282"><div class="ttname"><a href="../../de/d48/namespacethread__module.html#a5a2719d6d43f27e1e8e913fbfa5c9288acb5e100e5a9a3e7f6d1fd97512215282">thread_module::log_level::error</a></div><div class="ttdeci">@ error</div></div>
<div class="ttc" id="anamespacethread__module_html_ac36545c2cec0c3066226f519c089c5fda7b7ecb39b9e110c2a31409a1672bad23"><div class="ttname"><a href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fda7b7ecb39b9e110c2a31409a1672bad23">thread_module::thread_conditions::Stopping</a></div><div class="ttdeci">@ Stopping</div><div class="ttdoc">Thread in the process of stopping.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6d46b6122580eba745e1e1d56fa1571" name="ac6d46b6122580eba745e1e1d56fa1571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d46b6122580eba745e1e1d56fa1571">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto thread_module::thread_base::stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the worker thread to stop and waits for it to finish. </p>
<p>Stops the worker thread and waits for it to complete.</p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="../../dd/da2/classthread__module_1_1result__void.html" title="Wrapper for void result.">result_void</a></code> containing an error on failure, or success value if successful.</dd></dl>
<p>Internally, this method:</p><ol type="1">
<li>Signals the thread to stop (via <code>stop_source_</code> or <code>stop_requested_</code>).</li>
<li>Joins the thread, ensuring it has fully exited.</li>
<li>Calls <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a8a5b2eb7b63e97711e7bd58da331fc15" title="Called immediately after the worker thread has stopped.">after_stop()</a></code> for post-shutdown cleanup in derived classes.</li>
</ol>
<p>Implementation details:</p><ul>
<li>This method is idempotent - safe to call multiple times</li>
<li>First checks if there's actually a thread to stop</li>
<li>Uses platform-specific stop signaling:<ul>
<li>C++20: Uses std::stop_source for cooperative cancellation</li>
<li>Legacy: Sets atomic flag stop_requested_ to true</li>
</ul>
</li>
<li>Notifies condition variable to wake up waiting thread</li>
<li>Joins the thread to wait for complete shutdown</li>
<li>Cleans up all thread-related resources</li>
</ul>
<p>Shutdown Sequence:</p><ol type="1">
<li>Signal stop request using appropriate mechanism</li>
<li>Notify condition variable to wake sleeping thread</li>
<li>Wait for thread to exit its main loop and complete <a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#a8a5b2eb7b63e97711e7bd58da331fc15" title="Called immediately after the worker thread has stopped.">after_stop()</a></li>
<li>Clean up thread object and stop control mechanism</li>
<li>Update thread_condition_ to Stopped state</li>
</ol>
<p>Thread Safety:</p><ul>
<li>Safe to call from any thread including the worker thread itself</li>
<li>Uses proper synchronization to avoid race conditions</li>
<li>join() ensures thread resources are properly released</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Empty result on success, error if thread wasn't running </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00333">333</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  334</span>    {</div>
<div class="line"><span class="lineno">  335</span>        <span class="comment">// Early exit if no thread to stop (idempotent behavior)</span></div>
<div class="line"><span class="lineno">  336</span>        <span class="keywordflow">if</span> (<a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a> == <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  337</span>        {</div>
<div class="line"><span class="lineno">  338</span>            <span class="keywordflow">return</span> result_void{<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#a5a2719d6d43f27e1e8e913fbfa5c9288acb5e100e5a9a3e7f6d1fd97512215282">error</a>{<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#a215ffba45222b5527566469d33e4447caf2be7360c604a961b720a704f214b53c">error_code::thread_not_running</a>, <span class="stringliteral">&quot;thread is not running&quot;</span>}};</div>
<div class="line"><span class="lineno">  339</span>        }</div>
<div class="line"><span class="lineno">  340</span> </div>
<div class="line"><span class="lineno">  341</span>        <span class="comment">// Only attempt to stop if thread is actually joinable</span></div>
<div class="line"><span class="lineno">  342</span>        <span class="keywordflow">if</span> (<a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a>-&gt;joinable())</div>
<div class="line"><span class="lineno">  343</span>        {</div>
<div class="line"><span class="lineno">  344</span>            <span class="comment">// Step 1: Signal the thread to stop using platform-specific mechanism</span></div>
<div class="line"><span class="lineno">  345</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  346</span>            <span class="keywordflow">if</span> (stop_source_.has_value())</div>
<div class="line"><span class="lineno">  347</span>            {</div>
<div class="line"><span class="lineno">  348</span>                stop_source_.value().request_stop();  <span class="comment">// Cooperative cancellation</span></div>
<div class="line"><span class="lineno">  349</span>            }</div>
<div class="line"><span class="lineno">  350</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  351</span>            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a2010dcfce6de6920651eccffebdfde21">stop_requested_</a> = <span class="keyword">true</span>;  <span class="comment">// Atomic flag for legacy mode</span></div>
<div class="line"><span class="lineno">  352</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  353</span> </div>
<div class="line"><span class="lineno">  354</span>            <span class="comment">// Step 2: Wake up the thread if it&#39;s waiting on condition variable</span></div>
<div class="line"><span class="lineno">  355</span>            {</div>
<div class="line"><span class="lineno">  356</span>                std::scoped_lock&lt;std::mutex&gt; lock(<a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a68e452ea7136f242b1e1b8e84758cd5c">cv_mutex_</a>);</div>
<div class="line"><span class="lineno">  357</span>                <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#adc1b2dce42e59a25d78761baf4dcf230">worker_condition_</a>.notify_all();  <span class="comment">// Wake all waiting threads</span></div>
<div class="line"><span class="lineno">  358</span>            }</div>
<div class="line"><span class="lineno">  359</span> </div>
<div class="line"><span class="lineno">  360</span>            <span class="comment">// Step 3: Wait for the thread to complete its shutdown sequence</span></div>
<div class="line"><span class="lineno">  361</span>            <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a>-&gt;join();  <span class="comment">// Blocks until thread exits</span></div>
<div class="line"><span class="lineno">  362</span>        }</div>
<div class="line"><span class="lineno">  363</span> </div>
<div class="line"><span class="lineno">  364</span>        <span class="comment">// Step 4: Clean up thread resources</span></div>
<div class="line"><span class="lineno">  365</span><span class="preprocessor">#ifdef USE_STD_JTHREAD</span></div>
<div class="line"><span class="lineno">  366</span>        stop_source_.reset();  <span class="comment">// Release stop_source</span></div>
<div class="line"><span class="lineno">  367</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  368</span>        <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a31ec9019ff9e44cbe30bafaef8febe45">worker_thread_</a>.reset();  <span class="comment">// Release thread object</span></div>
<div class="line"><span class="lineno">  369</span> </div>
<div class="line"><span class="lineno">  370</span>        <span class="comment">// Step 5: Update thread state to indicate complete shutdown</span></div>
<div class="line"><span class="lineno">  371</span>        <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a7c110270a743ffb7405d85738bc34fa5">thread_condition_</a>.store(<a class="code hl_enumvalue" href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fdac23e2b09ebe6bf4cb5e2a9abe85c0be2">thread_conditions::Stopped</a>);</div>
<div class="line"><span class="lineno">  372</span> </div>
<div class="line"><span class="lineno">  373</span>        <span class="keywordflow">return</span> {};</div>
<div class="line"><span class="lineno">  374</span>    }</div>
<div class="ttc" id="anamespacethread__module_html_a215ffba45222b5527566469d33e4447caf2be7360c604a961b720a704f214b53c"><div class="ttname"><a href="../../de/d48/namespacethread__module.html#a215ffba45222b5527566469d33e4447caf2be7360c604a961b720a704f214b53c">thread_module::error_code::thread_not_running</a></div><div class="ttdeci">@ thread_not_running</div></div>
<div class="ttc" id="anamespacethread__module_html_ac36545c2cec0c3066226f519c089c5fdac23e2b09ebe6bf4cb5e2a9abe85c0be2"><div class="ttname"><a href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fdac23e2b09ebe6bf4cb5e2a9abe85c0be2">thread_module::thread_conditions::Stopped</a></div><div class="ttdeci">@ Stopped</div><div class="ttdoc">Thread fully stopped.</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../da/d94/classthread__module_1_1thread__base_ac6d46b6122580eba745e1e1d56fa1571_icgraph.png" border="0" usemap="#ada/d94/classthread__module_1_1thread__base_ac6d46b6122580eba745e1e1d56fa1571_icgraph" alt=""/></div>
<map name="ada/d94/classthread__module_1_1thread__base_ac6d46b6122580eba745e1e1d56fa1571_icgraph" id="ada/d94/classthread__module_1_1thread__base_ac6d46b6122580eba745e1e1d56fa1571_icgraph">
<area shape="rect" title="Requests the worker thread to stop and waits for it to finish." alt="" coords="224,5,395,45"/>
<area shape="rect" href="../../da/d94/classthread__module_1_1thread__base.html#a32f96f73af7e93a9ed8595b5921f0d08" title="Virtual destructor. Ensures proper cleanup of derived classes." alt="" coords="5,5,176,45"/>
<area shape="poly" title=" " alt="" coords="210,28,176,28,176,23,210,23"/>
</map>
</div>

</div>
</div>
<a id="a08ab300ad2b8a1e7f46a6f669cbfe31e" name="a08ab300ad2b8a1e7f46a6f669cbfe31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ab300ad2b8a1e7f46a6f669cbfe31e">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto thread_module::thread_base::to_string </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; std::string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string representation of this <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> object. </p>
<p>Provides a string representation of the thread's current state.</p>
<dl class="section return"><dt>Returns</dt><dd>A string containing descriptive or diagnostic information about the thread.</dd></dl>
<p>Derived classes may override this to include additional details (e.g., current status, counters, or other state).</p>
<p>Implementation details:</p><ul>
<li>Uses the formatter utility to create consistent output format</li>
<li>Includes both thread title and current condition</li>
<li>Useful for logging and debugging purposes</li>
<li>Thread-safe due to atomic load of thread_condition_</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Formatted string showing thread title and current state </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00415">415</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  416</span>    {</div>
<div class="line"><span class="lineno">  417</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="../../d1/daf/classutility__module_1_1formatter.html#a1b5ec167f6e47412edd77a4ea658e339">formatter::format</a>(<span class="stringliteral">&quot;{} is {}&quot;</span>, <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a87e3d20e8ca3c6da11c85f9f191abda0">thread_title_</a>, <a class="code hl_variable" href="../../da/d94/classthread__module_1_1thread__base.html#a7c110270a743ffb7405d85738bc34fa5">thread_condition_</a>.load());</div>
<div class="line"><span class="lineno">  418</span>    }</div>
<div class="ttc" id="aclassutility__module_1_1formatter_html_a1b5ec167f6e47412edd77a4ea658e339"><div class="ttname"><a href="../../d1/daf/classutility__module_1_1formatter.html#a1b5ec167f6e47412edd77a4ea658e339">utility_module::formatter::format</a></div><div class="ttdeci">static auto format(const char *formats, const FormatArgs &amp;... args) -&gt; std::string</div><div class="ttdoc">Formats a narrow-character string with the given arguments.</div><div class="ttdef"><b>Definition</b> <a href="../../de/d52/formatter_8h_source.html#l00176">formatter.h:176</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../da/d94/classthread__module_1_1thread__base_a08ab300ad2b8a1e7f46a6f669cbfe31e_cgraph.png" border="0" usemap="#ada/d94/classthread__module_1_1thread__base_a08ab300ad2b8a1e7f46a6f669cbfe31e_cgraph" alt=""/></div>
<map name="ada/d94/classthread__module_1_1thread__base_a08ab300ad2b8a1e7f46a6f669cbfe31e_cgraph" id="ada/d94/classthread__module_1_1thread__base_a08ab300ad2b8a1e7f46a6f669cbfe31e_cgraph">
<area shape="rect" title="Returns a string representation of this thread_base object." alt="" coords="5,5,176,45"/>
<area shape="rect" href="../../d1/daf/classutility__module_1_1formatter.html#a1b5ec167f6e47412edd77a4ea658e339" title="Formats a narrow&#45;character string with the given arguments." alt="" coords="224,5,411,45"/>
<area shape="poly" title=" " alt="" coords="176,23,210,23,210,28,176,28"/>
<area shape="rect" href="../../d1/daf/classutility__module_1_1formatter.html#a0e0cfc83510413df54bdf125abddbfbf" title=" " alt="" coords="459,5,645,45"/>
<area shape="poly" title=" " alt="" coords="411,31,445,32,445,37,411,37"/>
<area shape="poly" title=" " alt="" coords="458,19,424,19,424,14,458,14"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../da/d94/classthread__module_1_1thread__base_a08ab300ad2b8a1e7f46a6f669cbfe31e_icgraph.png" border="0" usemap="#ada/d94/classthread__module_1_1thread__base_a08ab300ad2b8a1e7f46a6f669cbfe31e_icgraph" alt=""/></div>
<map name="ada/d94/classthread__module_1_1thread__base_a08ab300ad2b8a1e7f46a6f669cbfe31e_icgraph" id="ada/d94/classthread__module_1_1thread__base_a08ab300ad2b8a1e7f46a6f669cbfe31e_icgraph">
<area shape="rect" title="Returns a string representation of this thread_base object." alt="" coords="268,57,439,97"/>
<area shape="rect" href="../../d3/da4/structfmt_1_1formatter_3_01thread__pool__module_1_1thread__worker_01_4.html#ad8a4148b4d82df8d047f84254965eccc" title="Formats a thread_worker object as a string." alt="" coords="5,5,220,60"/>
<area shape="poly" title=" " alt="" coords="254,61,220,55,221,50,255,56"/>
<area shape="rect" href="../../d3/dca/structfmt_1_1formatter_3_01typed__thread__pool__module_1_1typed__thread__worker__t_3_01job__type_01_4_01_4.html#a53f30f143dc34e05063d40c9b28a5c4b" title="Formats a typed_thread_worker_t&lt;job_type&gt; instance as a string." alt="" coords="25,85,200,154"/>
<area shape="poly" title=" " alt="" coords="255,97,201,107,200,101,254,92"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a68e452ea7136f242b1e1b8e84758cd5c" name="a68e452ea7136f242b1e1b8e84758cd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e452ea7136f242b1e1b8e84758cd5c">&#9670;&#160;</a></span>cv_mutex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex thread_module::thread_base::cv_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex for synchronizing access to internal state and condition variables. </p>
<p><code>worker_condition_</code> is typically waited on by the worker thread, and the main thread may notify it to trigger wake-ups or shutdowns. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00309">309</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<a id="a2010dcfce6de6920651eccffebdfde21" name="a2010dcfce6de6920651eccffebdfde21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2010dcfce6de6920651eccffebdfde21">&#9670;&#160;</a></span>stop_requested_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; thread_module::thread_base::stop_requested_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An atomic flag to indicate that the thread should stop. </p>
<p>Set to <code>true</code> when <code><a class="el" href="../../da/d94/classthread__module_1_1thread__base.html#ac6d46b6122580eba745e1e1d56fa1571" title="Requests the worker thread to stop and waits for it to finish.">stop()</a></code> is called, signaling the worker thread to exit its loop. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00345">345</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<a id="a7c110270a743ffb7405d85738bc34fa5" name="a7c110270a743ffb7405d85738bc34fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c110270a743ffb7405d85738bc34fa5">&#9670;&#160;</a></span>thread_condition_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="../../de/d48/namespacethread__module.html#ac36545c2cec0c3066226f519c089c5fd">thread_conditions</a>&gt; thread_module::thread_base::thread_condition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current condition/state of the thread (e.g., running, stopped). </p>
<p>Used internally to track whether the thread is active or if it has been requested to stop. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00359">359</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<a id="a87e3d20e8ca3c6da11c85f9f191abda0" name="a87e3d20e8ca3c6da11c85f9f191abda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e3d20e8ca3c6da11c85f9f191abda0">&#9670;&#160;</a></span>thread_title_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string thread_module::thread_base::thread_title_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A string title for identifying or naming the worker thread. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00351">351</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<a id="a47dad4325d074bf852e643aaf2e8fe95" name="a47dad4325d074bf852e643aaf2e8fe95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dad4325d074bf852e643aaf2e8fe95">&#9670;&#160;</a></span>wake_interval_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::chrono::milliseconds&gt; thread_module::thread_base::wake_interval_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interval at which the thread is optionally awakened. </p>
<p>If set, the worker thread can wake periodically (in addition to any other wake conditions) to perform tasks at regular intervals.</p>
<dl class="section note"><dt>Note</dt><dd>Access to this member must be synchronized using wake_interval_mutex_ </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00292">292</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<a id="a47f05db653b3f0c75635d939a4d03ce5" name="a47f05db653b3f0c75635d939a4d03ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f05db653b3f0c75635d939a4d03ce5">&#9670;&#160;</a></span>wake_interval_mutex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex thread_module::thread_base::wake_interval_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex for synchronizing access to the wake_interval_ member. </p>
<p>This mutex must be acquired when reading or writing wake_interval_ to prevent data races between the setter and the worker thread. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00301">301</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<a id="adc1b2dce42e59a25d78761baf4dcf230" name="adc1b2dce42e59a25d78761baf4dcf230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1b2dce42e59a25d78761baf4dcf230">&#9670;&#160;</a></span>worker_condition_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable thread_module::thread_base::worker_condition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Condition variable used to block or wake the worker thread. </p>
<p>Combined with <code>cv_mutex_</code>, this enables the worker thread to sleep until a specific event (e.g., a stop request or a timed interval) occurs. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00317">317</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<a id="a31ec9019ff9e44cbe30bafaef8febe45" name="a31ec9019ff9e44cbe30bafaef8febe45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ec9019ff9e44cbe30bafaef8febe45">&#9670;&#160;</a></span>worker_thread_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::thread&gt; thread_module::thread_base::worker_thread_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <code>std::thread</code> for managing the worker thread's lifecycle (legacy mode). </p>
<p>If <code>USE_STD_JTHREAD</code> is not defined, we fall back to a standard thread and an atomic stop flag. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00338">338</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>core/base/include/<a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a></li>
<li>core/base/src/<a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 13 2025 00:15:16 for Thread System by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
