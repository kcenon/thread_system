# Thread System - 성능 기준 메트릭

[English](BASELINE.md) | **한국어**

**버전**: 1.0.0
**날짜**: 2025-10-09
**단계**: Phase 0 - Foundation
**상태**: 기준선 확립

---

## 시스템 정보

### 하드웨어 구성
- **CPU**: Apple M1 (ARM64)
- **코어 수**: 8 (성능 코어 4 + 효율 코어 4)
- **RAM**: 8 GB
- **스토리지**: SSD

### 소프트웨어 구성
- **OS**: macOS 26.1
- **컴파일러**: Apple Clang 17.0.0.17000319
- **빌드 타입**: Release (-O3)
- **C++ 표준**: C++20

### 빌드 구성
```cmake
CMAKE_BUILD_TYPE=Release
CMAKE_CXX_FLAGS="-O3 -DNDEBUG -std=c++20"
```

---

## 성능 메트릭

### Thread Pool 성능

#### 표준 Thread Pool
- **처리량**: 1,160,000 jobs/second
- **지연시간**: 평균 <1 μs
- **확장성**: 8 스레드까지 선형적
- **메모리**: 기준선 ~2 MB

#### Typed Thread Pool
- **처리량**: 1,240,000 jobs/second (표준 대비 +7%)
- **지연시간**: 평균 <1 μs
- **타입 안전성**: 컴파일 타임 검증
- **메모리**: 기준선 ~2 MB

### Adaptive Queue 성능
- **Enqueue**: 50-100 ns/operation
- **Dequeue**: 50-100 ns/operation
- **경합 처리**: 낮은 경합 시 lock-free
- **동적 크기 조정**: 자동 용량 조정

### Job 실행 메트릭
- **제출 오버헤드**: <50 ns
- **Context Switch**: ~5 μs
- **스레드 시작**: ~1 ms
- **스레드 종료**: ~2 ms

---

## 벤치마크 결과

### 처리량 벤치마크

| 구성 | Jobs/Second | 비고 |
|------|-------------|------|
| 1 스레드 | 350,000 | 단일 스레드 기준선 |
| 2 스레드 | 680,000 | 거의 선형적 확장 |
| 4 스레드 | 1,160,000 | M1 성능 코어에 최적 |
| 8 스레드 | 1,240,000 | 최대 처리량 |
| 16 스레드 | 1,200,000 | 수익 감소 |

### 지연시간 벤치마크 (P50/P95/P99)

| 작업 | P50 | P95 | P99 |
|------|-----|-----|-----|
| Job 제출 | 0.8 μs | 1.2 μs | 2.0 μs |
| Job 실행 | 0.5 μs | 1.0 μs | 1.5 μs |
| Queue 연산 | 0.05 μs | 0.1 μs | 0.2 μs |

### 메모리 벤치마크

| 구성 | 메모리 사용량 | 최대치 | 비고 |
|------|---------------|--------|------|
| 빈 Pool | 1.8 MB | 2.0 MB | 기준선 오버헤드 |
| 1K Jobs 대기 | 2.5 MB | 3.0 MB | Job 저장소 |
| 10K Jobs 대기 | 8.2 MB | 10 MB | 높은 부하 |
| 100K Jobs | 72 MB | 80 MB | 스트레스 테스트 |

---

## 확장성 분석

### 스레드 확장 효율성

| 스레드 수 | 처리량 | 효율성 | 비고 |
|-----------|--------|--------|------|
| 1 | 350K jobs/s | 100% | 기준선 |
| 2 | 680K jobs/s | 97% | 우수한 확장 |
| 4 | 1.16M jobs/s | 83% | 양호한 확장 |
| 8 | 1.24M jobs/s | 44% | 경합 효과 |

### 부하 패턴

**정상 상태**:
- 일관된 1.24M jobs/sec 처리량
- 최소한의 지연시간 변동
- 안정적인 메모리 사용량

**버스트 부하**:
- 10K job 버스트를 <10ms에 처리
- 과부하 시 점진적 성능 저하
- Queue backpressure 메커니즘

**혼합 워크로드**:
- CPU 집약적: 1.1M jobs/sec
- I/O 집약적: 1.3M jobs/sec
- 혼합: 1.2M jobs/sec

---

## 비교 분석

### 이전 버전과 비교
| 메트릭 | 이전 | 현재 | 변화 |
|--------|------|------|------|
| 처리량 | 1.1M jobs/s | 1.24M jobs/s | +13% |
| 지연시간 (P50) | 1.2 μs | 0.8 μs | -33% |
| 메모리 | 3.0 MB | 2.0 MB | -33% |

### 업계 표준과 비교
| 라이브러리 | 처리량 | 지연시간 | 메모리 | 비고 |
|-------------|---------|----------|--------|------|
| **thread_system** | **1.24M/s** | **0.8 μs** | **2 MB** | 본 시스템 |
| std::async | 100K/s | 10 μs | 10 MB | 표준 라이브러리 |
| TBB | 1.0M/s | 1.0 μs | 5 MB | Intel TBB |
| Folly | 1.1M/s | 0.9 μs | 3 MB | Facebook Folly |

---

## 성능 특성

### 강점
- ✅ **초고속 처리량**: 1.24M jobs/second
- ✅ **서브 마이크로초 지연시간**: P50 < 1 μs
- ✅ **우수한 확장성**: 4 코어까지 거의 선형적
- ✅ **낮은 메모리 사용량**: 2 MB 기준선
- ✅ **적응형 queue**: 자동 크기 조정 및 최적화

### 적용된 최적화
- 낮은 경합 시 lock-free 알고리즘
- 동시성 구조를 위한 cache-line 정렬
- 부하 분산을 위한 work stealing
- SIMD 친화적 데이터 레이아웃 (ARM NEON)
- 스마트 포인터 오버헤드 최소화

### 알려진 제한사항
- **8+ 스레드에서의 경합**: 효율성이 44%로 감소
- **큰 job 오버헤드**: >1KB job은 10% 처리량 감소
- **캐시 효과**: 성능이 job 복잡도에 따라 변동

---

## 테스트 방법론

### 벤치마크 환경
- **격리**: 단일 사용자 시스템, 백그라운드 부하 없음
- **워밍업**: 측정 전 10,000회 연산
- **반복**: 테스트당 1,000,000회 연산
- **샘플**: 10회 실행, 중앙값 보고
- **분산**: 실행 간 <2%

### 워크로드 유형
1. **빈 Jobs**: 최소 작업, 오버헤드 측정
2. **CPU 집약적**: 정수 연산, ~1 μs 작업
3. **메모리 집약적**: 배열 연산, 캐시 테스트
4. **혼합**: 실제 애플리케이션 시나리오

---

## 기준선 검증

### Phase 0 요구사항
- [x] 벤치마크 인프라 구축 ✅
- [x] 반복 가능한 측정 ✅
- [x] 시스템 정보 문서화 ✅
- [x] 성능 메트릭 기준선 설정 ✅
- [x] 회귀 감지 준비 완료 ✅

### 수락 기준
- [x] 처리량 > 1M jobs/second ✅ (1.24M)
- [x] 지연시간 < 2 μs (P50) ✅ (0.8 μs)
- [x] 메모리 < 5 MB 기준선 ✅ (2 MB)
- [x] 확장성 효율성 > 80% (4 스레드) ✅ (83%)

---

## 회귀 감지

### 경고 임계값
- **처리량**: 1.24M jobs/s에서 >5% 감소
- **지연시간**: 0.8 μs (P50)에서 >10% 증가
- **메모리**: 2 MB 기준선에서 >20% 증가
- **확장성**: >10% 효율성 저하

### 모니터링
- CI 파이프라인이 모든 PR에서 벤치마크 실행
- 성능 회귀가 병합을 차단
- benchmarks.yml artifacts에서 과거 추세 분석

---

## 참고자료

- README.md 벤치마크에서 성능 데이터 수집
- Google Benchmark 관행에 맞춘 방법론
- sysctl로 검증된 하드웨어 사양
- CMakeLists.txt의 빌드 구성

---

## 다음 단계

### Phase 1-2 영향 평가
- 스레드 안전성 변경 영향 모니터링
- RAII가 성능 회귀를 일으키지 않는지 확인
- 아키텍처 변경 시 기준선 업데이트

### Phase 3 고려사항
- Result<T> 오버헤드 측정
- 오류 처리 경로 성능
- Monadic 연산 비용

---

**문서 상태**: Phase 0 완료
**기준선 설정**: 2025-10-09
**다음 검토**: Phase 3 완료 후
**유지관리자**: kcenon
